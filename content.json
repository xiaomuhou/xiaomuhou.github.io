{"meta":{"title":"GUO-WM-0.0","subtitle":"你说我世上最坚强，我说你世上最善良","description":"时光流逝的飞快","author":"Ming","url":"http://xiaomuhou.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-08T12:25:41.000Z","updated":"2021-10-08T12:25:41.941Z","comments":true,"path":"about/index-1.html","permalink":"http://xiaomuhou.github.io/about/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-08T11:38:26.000Z","updated":"2021-10-09T02:24:39.375Z","comments":true,"path":"categories/index.html","permalink":"http://xiaomuhou.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2024-07-03T14:20:20.000Z","updated":"2024-07-03T14:21:09.441Z","comments":true,"path":"contact/index.html","permalink":"http://xiaomuhou.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-08T11:33:21.000Z","updated":"2021-10-09T02:23:33.459Z","comments":false,"path":"tags/index.html","permalink":"http://xiaomuhou.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-10-08T11:40:15.000Z","updated":"2024-08-17T14:15:38.021Z","comments":true,"path":"about/index.html","permalink":"http://xiaomuhou.github.io/about/index.html","excerpt":"","text":"[x] 机械自动化本科在读—2019已毕业 [x] 机械工程硕士在读—2021已毕业 航空宇航专业在读博士生，努力学习中… 记录一些笔记以及生活感想。 人生太漫长，希望能结识各种类型的人、做一些不一样的事情。 (有需要请联系邮箱xiaomuhguo@gmail.com)"}],"posts":[{"title":"年终总结2024","slug":"年终总结2024","date":"2024-12-30T15:10:29.000Z","updated":"2024-12-30T16:04:41.507Z","comments":true,"path":"2024/12/30/年终总结2024/","permalink":"http://xiaomuhou.github.io/2024/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%932024/","excerpt":"2024年末随想年末的倒数第二天，现在一个人呆在寝室胡思乱想，过去的一年经历了很多，也算是正向的一年，略作总结，希望2025也能好一点！（明晚估计得跟朋友出去干饭，没啥时间写了，今完随便写写）","text":"2024年末随想年末的倒数第二天，现在一个人呆在寝室胡思乱想，过去的一年经历了很多，也算是正向的一年，略作总结，希望2025也能好一点！（明晚估计得跟朋友出去干饭，没啥时间写了，今完随便写写） 学业还是先谈学业，毕竟这是眼下最重要的事情，论文有了一些保底，但是实验进度确实很慢，加工有点费劲，需要的东西太多，做好规划，尽快推进，对自己的专业还是要自信一些，踏踏实实的推进进度，跟翟师兄学习一下，迅速掌握一套基本方法并且应用真的是个很重要的能力，复现-套用，每一步都得认真思考，难理解意味着摸到了门槛，爬过去才有进度，认真一点，踏实一点，也不说一定啥时候毕业，只能说2025尽力而为，踏实的走好每一步。 生活今年把游泳卡用完了，算是坚持下来了一个运动爱好，虽然还是只会蛙泳hh，体重啥的只能说还挺稳定，不过健康就好吧，放纵餐吃的有点过于好了，人生在世，吃喝二字，保证健康的前提下，还是开心最重要，2025继续坚持，也改改周末的饮食习惯，也想去到处吃一吃好吃的食物，民以食为天，一直觉得食物是感知每个地方灵魂的重要途径，沈阳的拉面真好吃，如果未来会呆在东北，那我只愿意呆在沈阳。 为人处世这个就不总结，其实很清楚自己有啥缺点，不经意会暴露出来，人性始然，写几点勉励自己把，其实过去的笔记也有记录： 1.少说废话，克制虚荣心。 2.做了什么事，如果做了就不要后悔，过于内耗反而不好，如果做了错的事，也要反思，前世之师后车之鉴还是有必要的。 3.不要受别人的干扰，大家都好都开心，才是最好的局面，保持好情绪，安安静静的。 4.性格过于摸鱼，效率提高点，总是害怕难题，踏实一点，硬骨头还是得一口一口啃。 5.算是心思比较细腻吧，其实经常可以感受到对方的想法，但是还是像往常一样吧，我做事是无所求的，希望大家都开心，并不求得到什么，有时候别人开心我也会开心，这也是做一些事情的原因，本质单纯只是为了自己开心，其实没啥别的想法，希望别人也不要多想，仅此而已。 瞎溜达今年跑去了烟台、高密、泰安、沈阳、大连玩，很开心，也吃了很多好吃的，多出去转转还是心情愉悦，明年希望也有时间出去瞎溜达，不过也要努力毕业了。高密炉包太腻了不好吃，还是沈阳的饭合我胃口，泰安也很不错，都是很好的地方，不过我还是最喜欢成都，好吃的有点多，唯一缺陷是火锅没有麻酱，山东其实也蛮不错，至少老哥那里我还呆的蛮习惯的，安居乐业才是终极目标啊，确实有个自己的小窝才会安心。 积累马上在哈尔滨第十年了，4年本科，2年硕士，还有仍在继续的博士，认识自己，走好每一步吧， 支付宝攒了一些钱了，没有什么炒股的想法，单纯觉得很麻烦，就继续放着吧，未来可能会买一些定期存存，毕业能买一辆老哥那个车了233，平时确实也没啥花销，也就游戏还有和朋友吃饭，明年要多去做一些没体验过得事情，钱重要但是也不重要，看淡一些。 规划工作事情要带上脑子了，简历其实改了几版了，继续慢慢修改，也要多想想自己到底想做什么，每天目标也要完成，开始就做最重要的事情，任何时候都是。 要活的潇洒一点，自信一点，少纠结，拥抱未来，2025加油呀，希望大家都好，世界都好，想做事情就一定去做，今年下决心做的事情基本都成了，所以未来也是，加油！！！","categories":[{"name":"thought2024","slug":"thought2024","permalink":"http://xiaomuhou.github.io/categories/thought2024/"}],"tags":[{"name":"life","slug":"life","permalink":"http://xiaomuhou.github.io/tags/life/"}]},{"title":"心情随笔20241129","slug":"心情随笔20241129","date":"2024-11-29T15:04:02.000Z","updated":"2024-11-29T15:34:13.707Z","comments":true,"path":"2024/11/29/心情随笔20241129/","permalink":"http://xiaomuhou.github.io/2024/11/29/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%9420241129/","excerpt":"心情随笔 少有的没控制住情绪，做好自己的事情，少去管别人，虽然有人说话确实非常讨厌，但是被他激怒也是自己情绪上有点不对，自己想做一件事情，就去做，做到自己能做的所有事情，至于别人的行动其实无关紧要。","text":"心情随笔 少有的没控制住情绪，做好自己的事情，少去管别人，虽然有人说话确实非常讨厌，但是被他激怒也是自己情绪上有点不对，自己想做一件事情，就去做，做到自己能做的所有事情，至于别人的行动其实无关紧要。 克制自己的表达欲望，还是少说话，少去说教别人，最近还是说了一些错的事情，但是倒没咋后悔，只是觉得不太合适，少说话啦，压制过分的炫耀欲； 你要克服的是你的虚荣心，是你的炫耀欲，你要对付的是你时刻想要冲出来想要出风头的小聪明； 确实至理名言，要常常铭记复习； 关于后续规划： 1.大样机及相关实验，需要一个文档，锁定思考 2.后续内容，研究cy师兄的速度推导，确定方向，局部规划； 3.静力学刚度差异性分析、微分运动学、控制内容。 其余的没想到啥，最近的进度还可以，但是也摸了一段时间，还好还好； 生活上，坚持游泳，至少接下来是的，饮食要规律，上周聚餐太多次了，注意一下。 每个人的缺点无法避免，但是可以反思克制就好，开心一点~ 按照安排慢慢来，12月要再完成一部分工作，年前再完成一部分，要看一些有趣的电影… 放个最近感觉很好吃的川菜~","categories":[{"name":"feel","slug":"feel","permalink":"http://xiaomuhou.github.io/categories/feel/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://xiaomuhou.github.io/tags/emo/"}]},{"title":"缩短时间尺度","slug":"缩短时间尺度","date":"2024-10-13T15:34:33.000Z","updated":"2024-11-29T15:35:07.143Z","comments":true,"path":"2024/10/13/缩短时间尺度/","permalink":"http://xiaomuhou.github.io/2024/10/13/%E7%BC%A9%E7%9F%AD%E6%97%B6%E9%97%B4%E5%B0%BA%E5%BA%A6/","excerpt":"平常心，慢慢来最近问题缠身，课题全是困难，事情很多，慢慢来 踏踏实实的去做，别着急，对比思考一下后面的内容；","text":"平常心，慢慢来最近问题缠身，课题全是困难，事情很多，慢慢来 踏踏实实的去做，别着急，对比思考一下后面的内容； 10月中旬，10月底的节点，下一周需要完成的是： 1.分割顶点的两部分内容，这部分工作很有特色，边学边改 2.新的组合运动学，考虑了厚度影响 3.对结果进行分析讨论，学一下hanyouc，总结分析与讨论 总的来讲，都是工作总结，不需要新的内容，按进度推进就好，虽然事项比较多，保持平常心一件一件去做就好。 11月，新的内容完成，shape inverse control and dynamic, 12月，除了正常学业外，需要去上海一躺，见个好朋友。 之后看论文，着重总结一下实验分类、实验讨论以及所谓的深入点，总结思考一下。 事情很多，心里总是很烦，但是缩短时间尺度，吃饭睡觉的时候还蛮开心的，跟朋友聊天的时候也很开心，想太远总是很无聊，眼前事做好就算了，填一下桌面端app的daily calendar 志哥的发言还蛮有启发的，之前做的对应还是不够，认真一点； 上周乱七八糟得，条理一点，少摸鱼少摸鱼，求其上得其中，其他随缘~","categories":[{"name":"EMO","slug":"EMO","permalink":"http://xiaomuhou.github.io/categories/EMO/"}],"tags":[{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/tags/emotion/"}]},{"title":"空间渐进曲线Matlab","slug":"空间渐进曲线Matlab","date":"2024-10-02T14:49:32.000Z","updated":"2024-10-02T15:26:52.146Z","comments":true,"path":"2024/10/02/空间渐进曲线Matlab/","permalink":"http://xiaomuhou.github.io/2024/10/02/%E7%A9%BA%E9%97%B4%E6%B8%90%E8%BF%9B%E6%9B%B2%E7%BA%BFMatlab/","excerpt":"空间曲线拟合笔记渐进颜色修正与一点点origin 基础信息与参数说明","text":"空间曲线拟合笔记渐进颜色修正与一点点origin 基础信息与参数说明 基础参数 subplot(2, 2, 1); plot(x, y);参考源文件‘ patch 利用填充函数绘制渐进曲线颜色,也可以用来表示边的颜色插补 ‘flat‘ - 对每个网格线段和面使用恒定颜色。 该颜色由该线段的端点或该面的角边处具有最小索引的颜色值确定。 ‘interp‘ - 对每个线段和面使用插补着色。 123456789patch(x,y,z,'edgecolor','flat','facecolor','none','MarkerFaceColor','flat','LineWidth',2) %会导致封闭连接patch([x NaN],[y NaN,[z NaN],'edgecolor','flat','facecolor','none','MarkerFaceColor','flat','LineWidth',2)view(3)grid on; colorbar%官方文档figurepatch(x,y,c,'EdgeColor','interp','Marker','o','MarkerFaceColor','flat');colorbar; Fill 12p=fill3(x,y,z,'r')p.FaceAlpha = 0.5; FaceAlpha — 面透明度 1 (默认) | 范围 [0,1] 中的标量 | 'flat' | 'interp' EdgeColor— 边颜色[0 0 0](默认) |‘none’|‘flat’|‘interp’| RGB 三元组 | 十六进制颜色代码 |‘r’|‘g’|‘b’` | …代码 代码补充（假期后整理现阶段代码）代填 origin补充","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://xiaomuhou.github.io/tags/learning/"}]},{"title":"中期-生活-随想","slug":"中期-生活-随想","date":"2024-09-22T14:23:36.000Z","updated":"2024-09-22T15:30:37.699Z","comments":true,"path":"2024/09/22/中期-生活-随想/","permalink":"http://xiaomuhou.github.io/2024/09/22/%E4%B8%AD%E6%9C%9F-%E7%94%9F%E6%B4%BB-%E9%9A%8F%E6%83%B3/","excerpt":"中期结束之后的随笔有些感慨，突如其来的迷茫，若有若无的思绪 浅浅记录，来日可追~","text":"中期结束之后的随笔有些感慨，突如其来的迷茫，若有若无的思绪 浅浅记录，来日可追~ ​ 低效的生活总是带给人迷惘，原本希望规律的习惯可以塑造思维，长时间下来虽有些许效果，但是仍在边边角角，主题推进慢慢悠悠，思考下来还是自己遇到困难下意识逃避，不够专注，然后思维涣散，开始摸鱼，仔细想来，浪费的时间有4个月，扣除掉放假瞎溜达，也有3个月，不奢望每天都可以高效推进，但总归没有多余的时间再如此休闲了，该做的事情也应该认真的去做了,在此记录一下，略作督促。 学业中期结束之后，感觉确实进度慢，主要是两个部分： 规划的动力学其实存在一些问题，早先有些想当然，当初刘老师的说的缝隙问题到今天才理解了是什么意思，有点喜剧了，看来不可以按照分段耦合的方法去做，这条路是走不通的，跟两位师兄的沟通其实也验证了这一点，但是貌似也不是完全走不下去，直接用点去链接被动变形的连续体，我做的这个东西特色还是非常明显的，走这条路的问题就是不能考虑柔性结构的反作用力，直接去建造刚体动力学模型，真正的把驱动视为干扰，不去考虑建模问题，动力学目的变成优化问题，与四面体相比优势在于维度，两侧各自出现两条连续的控制点，本质上也是封闭的曲面控制，能够提供更多的点位控制，本身也是一种方案，只是严谨的理论模型就不能去做了，里面是个大坑，容易陷进去，绕一下，这个问题目前还不需要解决，慢慢思考吧。 模型的优化问题，这个是当下急需解决与思考的一个问题，主要是球副那个部分的实际轴线问题，以及相交面位置旋转模型的细化，球借鉴一下赵师兄的球副，其余需要尽快拿出细节方案，然后adams之类的仿真需要开始，这部分近期要开始思考落实，目标是完成一套二代模型—应该是没问题的默认一个两驱动的八面体，既然李可以2P1R，那就说明两驱没问题，问题就在于细化了。 小论文，就是需要尽快投，有三个问题，一是包装，分割顶点部分需要拔高一下，目前的有点low，二是模式转换，速率比不可以那样直接去说，是有问题的，这部分需要思考改进，其实后面放个精细版本的三维模型更好，所以得同步推进。分割包装、速率说明，大概需要一周的时间吧。 软著，这个其实可以放放，抽空去写完成一下 习惯要认真写，上午下午晚上不能无目的的摸鱼了，这个很重要，注重一下，求其上才能得其中 安安静静的推进进度，务实一点。 论文习惯、运动习惯、学习按照往常继续就好，多多游泳去了，现在是9月22日，11月底 生活本来就是个比较喜欢一个人呆着的人，现在这个状态也蛮好，前几天去当义工，感觉还蛮开心的，不带目的帮助陌生人体验还可以，就是自己有点质疑活动本身的意义，下次应该也不会再去了，下一步想做的事情是自驾游。 自己做这些没啥意义的事，本质还是为了让自己可以开心一点，散散心，没啥高尚的想法。 最近觉得自己做的很好的一件事情就是已经能够做到下意识的去换位思考了，不去把自己的想法强加给别人，吃饭是这样，为人做事也是这样，更成熟了一点，做一个控制欲望为0的人，大家都做自己想做的事情，不要互相干扰。 喜欢，经历之前的事情再加上这几年来的事情，感觉自己变得有点现实，权衡开始成了判断的前提，做好自己，还是去接触一下，不要封闭自己，拒绝别人也不太好，也和习惯规划有点相关，12月吧大概就这样~ 大目标！算了不立flag了，踏踏实实的做好眼前的事情吧。","categories":[{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/categories/emotion/"}],"tags":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/tags/note/"}]},{"title":"互联网生存","slug":"互联网生存","date":"2024-08-21T14:29:16.000Z","updated":"2024-08-22T14:16:40.543Z","comments":true,"path":"2024/08/21/互联网生存/","permalink":"http://xiaomuhou.github.io/2024/08/21/%E4%BA%92%E8%81%94%E7%BD%91%E7%94%9F%E5%AD%98/","excerpt":"互联网辩论网上冲浪看到了一些不好的言论，而且是自己一个很喜欢的博主发的，感觉很难过，于是默默取关了，然后想悄悄的聊聊。","text":"互联网辩论网上冲浪看到了一些不好的言论，而且是自己一个很喜欢的博主发的，感觉很难过，于是默默取关了，然后想悄悄的聊聊。 网络行为观察互联网上言论千奇百怪，各种弱智的言论存在都是合理的，当然看到一些自诩高尚但是喜欢和弱智大战三百回合的人也不在少数，但是我一直觉得能和明显反智的言论斗智斗勇的人，也应该反思一下，你到底是在维护正义，还是在捏软柿子从而获得优越感，说的有点过分，可能只是朴素的正义感作祟，但是后续如果借着这个软柿子宣扬自己观点的，那不用判断了，也是个弱智。 有些人喜欢骂小粉红，骂各种笨蛋操作，我觉得他们潜意识里其实是喜欢这些人的，只是自己没有发现，没有这些人，他们廉价的优越感就会消失，失去了所谓的乐趣，从这一点来看，他们是站在一起的。 有些人一看到群体行为出现，立马站在对面，也不去思考自己讨厌的是事情本身还是群体部分不理智的人群，总之就是一顿AOE,看到一些不理智的言论，立马借题发挥，自己把自己塑造成一夫当关的形象，还觉得自己悲壮且高尚，其实没选择拉黑不理的那一刻，你已经跟你借着发挥的人站在一起，一样的卑劣。 大家可能会讲，这样会不会助长不正之风？其实不然，说实话，忽视才是最好的手段，灭火最有效的向来都是惰性气体，温度的高度不能代表什么。 个体行为思考作为一个经常偶尔在游戏群冒泡的人，总会看到吵来吵去，但我又想和一些人沟通，所以我经常是默默把我不喜欢的人拉黑，我不会向你宣告，只是默默地忽视你，所以这么多年来基本没跟人吵过架。 寻找存在感本身不是个贬义词，每个人的一生都是在寻找自己存在的意义，但是不能频繁刷存在感，尤其是对个人。 网上冲浪，看到很反感的人或者言论，默默拉黑，如果不符合社区规则，顺便送一个举报，然后感觉自己冲浪的环境就好了很多，这里表扬一下B站，拉黑之后不会再看到这些人，微博就不然，始终锲而不舍的给我推送垃圾，但是微博又是中文环境下时效最强的软件，只能没办法继续被它恶心，如果每个人都能做到控制自己情绪，忽视反智的言论，或许会平静很多吧，但是微博这种平台可能就赚不到钱了，这就是矛盾的世界hh 经常告诉自己不要因为一件事去否定别人，但是毕竟不是机器人，难免有时候情绪激动直接否定，但是一定要记住的是不要站在别人面前去刷否定的存在感，站在别人面前的那一刻就已经是个小丑了。 借自己最喜欢的电视剧士兵突击做个结尾，袁朗评价吴哲：“ 我喜欢他。知道为什么吗？坚持自己的原则，充满希望和乐观。重要的是，他能跟许三多这样的兵交朋友，这一点，就不会毁于他很容易产生的优越感 ”，年轻时候觉得自己像三多，不喜欢变化，后来觉得自己像成才，有时候有点自私，再后来觉得自己还是希望成为吴哲，经常告诉自己要平常心，说实话自己是不如三多和成才的，他们有各自的强项，但我很希望成为吴哲一类的人，做一个半吊子的理想主义者，充满希望和乐观。 碎碎念结束，感觉很生气就写个日记，写到这里已经完全没感觉了，人不是机器人，也可以理解。 图源[https://x.com/Hitoimim/status/1807718505602797820]","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/tags/emotion/"}]},{"title":"transformation_feel","slug":"transformation-feel/transformation-feel","date":"2024-08-16T15:10:54.000Z","updated":"2024-08-16T16:23:19.714Z","comments":true,"path":"2024/08/16/transformation-feel/transformation-feel/","permalink":"http://xiaomuhou.github.io/2024/08/16/transformation-feel/transformation-feel/","excerpt":"旋转变换的一些想法记录空间一点关于任意轴旋转，点变换之间的关系以及传统坐标转换的解读","text":"旋转变换的一些想法记录空间一点关于任意轴旋转，点变换之间的关系以及传统坐标转换的解读 旋转轴一般说法，已知P点在B坐标系下坐标，通过旋转矩阵可以求得P点在A坐标系下的坐标 { }^A P={ }_B^A R^B P也可以理解为，P点A坐标系下的原运动点通过旋转运动得到新的点P’，均基于A坐标系，与前者的区别在于对于点意义的理解，即坐标系为主体变换与以点为主体变换，旋转矩阵则是绕某一根轴旋转theta，绕任意轴按照这个方式理解。 { }^A P^{\\prime}=R(\\theta)^A P绕任意轴旋转的通式推导大家都很熟悉，本质也是在求取R的过程， P^{\\prime}=T \\cdot R \\cdot T^{-1} \\cdot P M=T(-x,-y,-z) \\cdot R x(-\\alpha) \\cdot R y(\\beta) \\cdot R z(\\theta) \\cdot R y(-\\beta) \\cdot R x(\\alpha) \\cdot T(x, y, z) \\left[\\begin{array}{cccc} u^2+\\left(v^2+w^2\\right) \\cos \\theta & u v(1-\\cos \\theta)-w \\sin \\theta & u w(1-\\cos \\theta)+v \\sin \\theta & \\left(a\\left(v^2+w^2\\right)-u(b v+c w)\\right)(1-\\cos \\theta)+(b w-c v) \\sin \\theta \\\\ u v(1-\\cos \\theta)+w \\sin \\theta & v^2+\\left(u^2+w^2\\right) \\cos \\theta & v w(1-\\cos \\theta)-u \\sin \\theta & \\left(b\\left(u^2+w^2\\right)-v(a u+c w)\\right)(1-\\cos \\theta)+(c u-a w) \\sin \\theta \\\\ u w(1-\\cos \\theta)-v \\sin \\theta & v w(1-\\cos \\theta)+u \\sin \\theta & w^2+\\left(u^2+v^2\\right) \\cos \\theta & \\left(c\\left(u^2+v^2\\right)-w(a u+b v)\\right)(1-\\cos \\theta)+(a v-b u) \\sin \\theta \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]前后的变换过程目的是将任意轴线与Z轴重合，然后恢复，保证相对基坐标系下进行变换，此时，P点表示A坐标下位置，而P‘表示A坐标系下旋转后的位置，这里附上已经验证过的matlab矩阵代码，方便使用： 1234RT=[u^2+(v^2+w^2)*cos(theta),u*v*(1-cos(theta))-w*sin(theta),u*w*(1-cos(theta))+v*sin(theta),(a1*(v^2+w^2)-u*(b1*v+c1*w))*(1-cos(theta))+(b1*w-c1*v)*sin(theta); u*v*(1-cos(theta))+w*sin(theta),v^2+(u^2+w^2)*cos(theta),v*w*(1-cos(theta))-u*sin(theta),(b1*(u^2+w^2)-v*(a1*u+c1*w))*(1-cos(theta))+(c1*u-a1*w)*sin(theta); u*w*(1-cos(theta))-v*sin(theta),v*w*(1-cos(theta))+u*sin(theta),w^2+(u^2+v^2)*cos(theta),(c1*(u^2+v^2)-w*(a1*u+b1*v))*(1-cos(theta))+(a1*v-b1*u)*sin(theta); 0,0,0,1] DH坐标及相对变换右乘的案例理解，动系指的各个阶段的坐标系，而非最终系（用词不标准，体会即可） 四面体作为一种稳定机构单元，其旋转过程中相邻旋转轴线的夹角是固定的，因此可以直接应用DH法获取各个轴系之间的运动关系，但是运动单元不然，各个轴线之间存在闭合并联支链，运动关系复杂，不能直接获取关系，应用四元数本身与直接在笛卡尔坐标系在进行变换的意义是相同的，只是表示方法不同，然后就四元数可以调用的包多一点，不需要基于原理摸代码，表示上也更为简单，但是后续的运动速度分析，存在一定问题，方案待定，需要进一步理解概念。 坐标A-B的变换，以四面体为例，两个相邻的轴线，以A系为基准，就难以寻找关系，以B系为基准，按照B系各个动坐标分阶段的变换获取关系，已知A-B,需要先平移后旋转，因此以第一阶段平移B动坐标为基础，初次平移结束，此时动B的Z轴与A的Z轴方向一致，因此按照此坐标则是沿着Z2轴正向平移，重合之后开始第二阶段的转换，该过程右乘。 总结，左乘最为常见，概念上右乘是指针对动坐标系，但是实际需要理解，针对的是A-B过程中每一次变换的动坐标系，而非最终合成B系，直接以B系进行参考，很容易糊涂，假设A-B,需要经过旋转1，平移1，旋转2，则DH关系转换中，则是以旋转1系，平移系，以及旋转2三个坐标系为基准依次右乘，其变换也是这个过程，据此可以理解转换公式，完成推导。 对称变换及速度关系待补充","categories":[{"name":"learning","slug":"learning","permalink":"http://xiaomuhou.github.io/categories/learning/"}],"tags":[{"name":"mathematic","slug":"mathematic","permalink":"http://xiaomuhou.github.io/tags/mathematic/"}]},{"title":"gbasisorder","slug":"gbasisorder/gbasisorder","date":"2024-08-12T13:48:34.000Z","updated":"2024-08-12T14:00:37.787Z","comments":true,"path":"2024/08/12/gbasisorder/gbasisorder/","permalink":"http://xiaomuhou.github.io/2024/08/12/gbasisorder/gbasisorder/","excerpt":"[Groebner basis] 三种排序（备份方便查询） 'degreeInverseLexicographic', 'degreeLexicographic', or 'lexicographic'","text":"[Groebner basis] 三种排序（备份方便查询） 'degreeInverseLexicographic', 'degreeLexicographic', or 'lexicographic' gbasis(poly) 123syms x ypoly = [x^2 + y^2 - 1; x - y^3];G = gbasis(poly); gbasis(poly, vars) 1234syms x y zpoly = [x^2 + y^2 - z^2; x - y*z];vars = [x, y, z];G = gbasis(poly, vars); gbasis(___, 'MonomialOrder', MonomialOrder) 123syms x ypoly = [x^2 + y^2 - 1; x - y^3];G = gbasis(poly, [x, y], 'MonomialOrder', 'grlex'); EXAMPLE: 1234567891011121314151617181920212223syms x y zf1 = x^2 + y^2 - z^2;f2 = x*y - 1;f3 = z - 1;polys = [f1; f2; f3];% Compute the Gröbner basisG = grobner(polys, [x, y, z]);% Solve the systemsolutions = solve(G, [x, y, z]);% Display the solutionsx_sol = solutions.x;y_sol = solutions.y;z_sol = solutions.z;disp('Solutions for x:');disp(x_sol);disp('Solutions for y:');disp(y_sol);disp('Solutions for z:');disp(z_sol); 1. Lexicographic Order (lex)Advantages: Simplicity: Easy to understand and implement. It’s straightforward because it follows a strict variable precedence, similar to dictionary order. Algorithm Efficiency: Often used in algorithms where the precedence of variables is crucial, such as in Gröbner basis computations where the structure of the ideal is dependent on the variable ordering. Predictability: Provides consistent results that can be easier to predict and verify, especially in systems where variable ordering is well-defined. Applications: Preferred in problems where the order of variables has a natural hierarchy or importance, such as certain optimization problems or algorithms where variable prioritization is essential. 2. Graded Lexicographic Order (grlex)Advantages: Degree Consideration: First organizes monomials by their total degree, which is useful in contexts where the degree of the polynomial plays a significant role. Balanced Comparison: Within monomials of the same total degree, it applies lexicographic ordering, which can provide a balance between degree and variable precedence. Ideal Theory: Commonly used in algebraic geometry and commutative algebra to handle polynomial ideals where total degree matters. Applications: Useful in Gröbner basis computations where maintaining a balance between total degree and variable order helps in simplifying polynomial systems, especially when dealing with polynomial equations where the degree of terms influences the structure. 3. Graded Reverse Lexicographic Order (grevlex)Advantages: Focus on Degree and Last Variables: Organizes monomials by total degree first, but within the same degree, it compares starting from the last variable, which can be useful in certain algebraic computations. Efficient Simplification: Often leads to more efficient simplifications in polynomial systems where last variables are less significant, and can simplify Gröbner basis computations by focusing on more “significant” terms first. Algebraic Variety: Provides a different perspective in solving polynomial systems, which can be advantageous in specific algebraic contexts or when dealing with varieties in algebraic geometry. Applications: Preferred in cases where polynomial systems or geometric problems benefit from handling terms with less importance first, such as certain types of algebraic geometry problems or when working with varieties where polynomial terms’ significance changes based on their position. Summary Lexicographic Order (lex): Simplifies understanding and implementation; predictable results. Graded Lexicographic Order (grlex): Balances degree and variable ordering; useful for polynomial systems where degree is significant. Graded Reverse Lexicographic Order (grevlex): Focuses on degree first and then the last variables; efficient in simplifying systems where less significant terms are processed earlier. 单论solve计算效率，化简之后的计算公式效率提高大概30%，删去分析 Gröbner 基阶次的内容。","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"algebraic","slug":"algebraic","permalink":"http://xiaomuhou.github.io/tags/algebraic/"}]},{"title":"随笔II","slug":"随笔II/随笔II","date":"2024-08-05T15:18:15.000Z","updated":"2024-08-18T15:29:16.002Z","comments":true,"path":"2024/08/05/随笔II/随笔II/","permalink":"http://xiaomuhou.github.io/2024/08/05/%E9%9A%8F%E7%AC%94II/%E9%9A%8F%E7%AC%94II/","excerpt":"平常心平常心~","text":"平常心平常心~ 做事要有耐心，要对家人有耐心，要对陌生人有耐心。 经常遇到自己不乐意的事情就容易表露出来，给人一种拒人千里的感觉，事后老后悔让别人不开心了，真的不太好，多点换位思考，耐心一点。 最近事情比较多，论文写的也不太顺利，其实内容上已经没有太大问题，运动模式部分还需要看数据才能判断怎么区分维度和驱动速度的关系，得得踏踏实实的推进实质内容了，8月5日周一，这周需要一些进度完成，动力学部分在运动模式部分加入一下，曲线规划也有一部分内容，至少20号之前要有个中期初版。 看了个医疗电视剧问心，结局还是停留在美好了，其实往后想想还是一堆问题，曾经向往真挚的情感，现在开始更多考虑现实，与一些朋友要保持距离，开开心心的聊天就行，柴米油盐才是生活的本质，人的成分也基本一致，漫长的时光会磨灭一切。 护士长因为自己产检，没有及时把钱打回账户，刚看到的时候，那一瞬间有点怪人家，连带着辩护都有些讨厌，后来一想，其实是可以理解得，毕竟人家的事情更重要，比较下来这边的事情也不是很重要，后来也可以澄清，突然开始觉得自己可恶，怎么可以怪人家，现实里也是，真得多想想，耐心一点耐心一点，绕绕路等等人呗~ 再就是年龄问题，平时看动漫看其他电视剧，看看主角的年龄总会觉得自己真老了，佟湘玉都说自己24岁，但是看看这个剧，又感觉自己也不是很老，培养一个医学博士需要耗费相当久的时间，虽然不是学医得，但是经历也算类似，所以还是希望像剧中人一样可以选择不受牵绊的去做一些自己想做的事情，没必要一直纠结。 毛晓彤确实有点甜分超标，过于可爱了属于是233 [x] 其实都不太重要，还是耐心比较重要，有时候自己麻烦一点，让别人舒心，后续也会开心一点，就这样，当然是对家人、对朋友。","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"EMO","slug":"EMO","permalink":"http://xiaomuhou.github.io/tags/EMO/"}]},{"title":"morphing_and_deformation","slug":"morphing-and-deformation/morphing-and-deformation","date":"2024-07-05T14:24:59.000Z","updated":"2024-08-12T13:45:51.461Z","comments":true,"path":"2024/07/05/morphing-and-deformation/morphing-and-deformation/","permalink":"http://xiaomuhou.github.io/2024/07/05/morphing-and-deformation/morphing-and-deformation/","excerpt":"morphing与deformation区别","text":"morphing与deformation区别 Shape Morphing Context: Shape morphing is typically discussed in areas where objects or materials are designed to change shape in a controlled, intentional, and often reversible manner. Applications: Computer Graphics and Animation: Smooth transitions between different shapes or forms, often used in character animations or special effects. Aerospace Engineering: Wings or other components that change shape to optimize performance under different conditions. Robotics: Soft robots that can change shape to navigate through different environments. Smart Materials: Materials that can change their shape in response to stimuli (e.g., temperature, light, electric fields). Example: “The development of shape morphing structures can lead to more efficient and adaptable aircraft designs.” Shape Deformation Context: Shape deformation is a broader term that encompasses any change in shape, whether it is controlled or due to external forces. It includes both elastic (reversible) and plastic (permanent) deformations. Applications: Physics and Mechanics: Studying how materials deform under various forces and conditions (e.g., tension, compression, shear). Materials Science: Understanding how different materials respond to stress and strain. Engineering: Designing structures and components that can withstand deformations without failing. Biology: Examining how biological tissues deform under pressure or during movement. Example: “The research analyzes the shape deformation of metal alloys under high stress to improve their performance in structural applications.” Academic and Idiomatic Use Shape Morphing: More specific and often used in advanced or niche fields. Conveys a sense of smooth and intentional transformation. Less common in general academic literature but highly relevant in fields like aerospace, robotics, and smart materials. Shape Deformation: More general and widely applicable across many scientific and engineering disciplines. Includes both controlled and uncontrolled changes in shape. More commonly found in academic papers, textbooks, and research articles across a broad range of subjects. Summary Shape Morphing: Best used when discussing specific, controlled, and often reversible shape changes in specialized contexts. Shape Deformation: More suitable for general discussions about changes in shape, whether controlled or due to external forces, across a wide range of scientific and engineering disciplines. Key Differences Influence often implies a more subtle or indirect impact, potentially over time. Example: “Her advice influenced my career path over the years.” Affect generally denotes a direct and immediate impact. Example: “The sudden change in temperature affected the crops.” 老黄采访记录： played the game,not the score just do your best,go to school,take the right classes,do your best,do you homework, dedicate your self to be a good student, that grades will take care of itself, if you go backwards,and you teach children just focus on the grades, they’ll take easier classes, ther’ll focus on just doing well in class and test but not learning and they might learn the wrong thing. they might take less risk,they might challenge themselves less i would prefer that our company challenges itself more, this discover unknown things, do things that no one else has ever done before, and be willing to fail, and be willing to learn along the way.,rather than i want you to deliver growth,growth,growth…growth margin,growth margin or whatever results. you cannot control those things. don’t worry about those things. and so i created a system called early indicators of future success. don’t worry about future sucess, worry about the early indicators of future success. and what are some of the things of early indicators ,you decide for yourself? what are the early indicatos that your believe will lead to future success. and that’s why our company focus on that. we don’t let somebody else decide for us. what’s the definition of success.as we thought we created ourselves. and that’s why the company has to go create those indicators on work don’t worry about anything else and the results will take care of yourself “Analyse” and “analysis” have the same grammatical roles and meanings as “analyze” and “analysis,” respectively, but with a difference in spelling. “Analyse” is the British English spelling, while “analyze” is the American English spelling. Both terms are used to describe the process of examining something in detail and the result of that process.AnalysePart of Speech: VerbDefinition: To examine something methodically and in detail, typically in order to explain and interpret it.Usage:Action: “Analyse” describes the action of examining and breaking down information into components to understand it better.Examples:”Scientists analyse data to draw conclusions.”“We need to analyse the results of the experiment.”AnalysisPart of Speech: NounDefinition: The detailed examination of the elements or structure of something.Usage:Result: “Analysis” refers to the process or the result of analysing something.Examples:”The analysis revealed important insights.”“Her analysis of the market trends was thorough and detailed.”Key DifferencesSpelling:Analyse: British English spelling of the verb.Analyze: American English spelling of the verb.Analysis: The spelling of the noun remains the same in both British and American English.Function:Analyse/Analyze: Describes the act or process of examining something.Analysis: Refers to the outcome or result of the examination process.Grammatical Role:Analyse/Analyze: Verb, used to describe an action.Analysis: Noun, used to describe a thing or concept.Context:Analyse/Analyze: Used when talking about performing the action of examining.Example: “They will analyse the financial statements.” (British English)Example: “They will analyze the financial statements.” (American English)Analysis: Used when referring to the completed work or the process of examination.Example: “The financial analysis was very insightful.”Examples in SentencesAnalyse (British English):“Before making a decision, it’s important to analyse all the available information.”“The software can analys 乱七八糟转载 不太过分就尽量忍让，开心就好。 家人、朋友和重要的人要放在优先位置。少数亲密朋友胜过一百个普通朋友。不要与老朋友失联。 做让你快乐的事，不要做让你不快乐的事。不要和满是负能量的人联系。 努力工作，但不要错过生活。成为专业领域的顶尖，找到自己的生产力系统，不要害怕冒险。 赚钱比花钱有趣，但在朋友、新体验、节省时间、旅行和事业上花的钱不要吝啬。 不要受人摆布。人们可以变得强大，自信与傲慢有区别，目标是前者。 -表面听话，骨子里全是叛逆。。。 为自己设定每天、每年和每十年的清晰目标。 -有点难，每天比较重要。 勇敢追求你想要的。如果你认为不做某事会后悔，那就去做。遗憾通常来自于没做的事 尽力帮助别人，对陌生人友好，即使在没人注意没有回报的时刻也要友好。 -无目的的帮助别人确实会很开心 要贪婪地学习。 - 经常尝试新事物：做新事物能让时间过得慢些，增加幸福感，保持生活有趣，还能防止思维僵化。每年在生活和工作中都要尝试一些重大、新颖、有挑战的事情。 学会原谅：要学会原谅他人。 -这个确实，只要不是太过分，影响小，能退一步就退一步，心里过去自己也能舒服。毕竟不能指望每个人十全十美。 不过分追求地位：地位没有真实价值维持不了多久，而且会让人感到空虚。 平等就行，所谓年纪辈分都是没意义的垃圾； 感恩和正确看待问题：学会感恩，不要过多抱怨，不要嫉妒别人的成功。有些人可能会嫉妒你的成功，你得学会忽略这些声音。 走自己的路，平常心就是这样 做行动派：做一个行动派，而不是只会空谈的人。 低头，很难呀 冷静思考：行动前先冷静思考几秒。如果你很愤怒，那就多思考几分钟。 不妄下定论：不要轻易对他人妄下定论，你可能永远无法完全了解他们的全部故事，要学会设身处地为他人着想。 体会人的复杂，慎重决定 不要轻易说‘很难’，不为失败找借口，只为成功找方法. 尝试","categories":[{"name":"GPT","slug":"GPT","permalink":"http://xiaomuhou.github.io/categories/GPT/"}],"tags":[{"name":"ACADEMIC","slug":"ACADEMIC","permalink":"http://xiaomuhou.github.io/tags/ACADEMIC/"}]},{"title":"心情随笔","slug":"心情随笔/心情随笔","date":"2024-05-15T14:36:32.000Z","updated":"2024-05-15T14:40:40.251Z","comments":true,"path":"2024/05/15/心情随笔/心情随笔/","permalink":"http://xiaomuhou.github.io/2024/05/15/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/","excerpt":"心情随笔，胡思乱想胡乱笔记，想到什么记什么。","text":"心情随笔，胡思乱想胡乱笔记，想到什么记什么。 无效预演最近发现一个不自主的问题，脑子里总是喜欢为不熟悉的事情做预演，但是其实是往往没啥作用，徒劳心力； 以KE为例，要注意区分用功复习与无效预演的差别，面对来临的安排，最好的做法就是只要没有必须拒绝的理由，就去接受，兵来将挡水来土掩，是一种从容的态度，之前二也是感觉很麻烦，但是结束之后又有一个还算完美的结局，所以接下来的事情，就继续下去； 间隙性分心：常常无法保持持续的专注力，上一次高效工作还是因为有个明确DDL的时候，反思一下，问题主要在于两个： 第一是目标比较模糊，虽然知道要去做哪个内容，但是缺少的内容不够明确，比方说已知需要看完那两篇博士论文，整理之前收集的SMM背景,目的是吸收方法，找一些新的分析工具，坐标转换想利用四元数，简洁表述，但是第一步还有问题，正无问题，逆所需要的信息、流程不明确，这是目前急需解决的问题，整理完论文应该就会有结果，周五之前需要结束。 第二没有完全切断干扰源，luna的视频给了我很大的启发，没有严格的限制就不会有强大的动力去切断干扰，自我设限催眠一下，是一个不错的手段，半执行状态已经能感受到方法的有效性，通过限制增加动力就可以。 第三短期目标的设置，按照工作量设定目标而非时间阶段非常有效，结合二去执行，受到限制，专注一点。 对短视频的思考：前几天看了油管上chenlily的新视频，没想到也在为短视频的问题困扰，对我而言，短视频（不以时间长短作为区分，内容含量上的短）其实无所谓，因为我平时也不会去看，我讨厌那些没头没尾的创作内容，持续性的刺激多巴胺，我认为是一种非常下作的创作方法，但是人生就是这样，兜里请揣满人民币，叛逆之前也需要让别人先看到你。 C之前就表达过为了生存和播放量必须开始制作，其实我能理解，也以为她已经想通了，感觉那还蛮好的，没想到停更了那么久，新视频依然还是在为这个事情困扰，真的是个很纯粹的人了，如果是我的话，以此为生，可能会去双线并行，坚持长vlog的制作，虽然更耗心力，但是这样会有更加长远的好处，观众盘会更加稳定，风评也会越来越好；短视频不会耗费太多精力，那就继续乘着风口挣钱，不要把两类视频的播放量混在一起思考，当成赚钱的工具就行，兴趣当成工作固然幸运，但是大多不得行，做人百分比这个问题真的是个永恒的话题。 乱七八糟的想法在这里依次补充： 20240514：用到或者有了明确的想法再去做。 想得太多会不会活得很累？","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/tags/emotion/"}]},{"title":"skill","slug":"skill/skill","date":"2024-03-20T15:25:10.000Z","updated":"2024-03-20T15:26:12.924Z","comments":true,"path":"2024/03/20/skill/skill/","permalink":"http://xiaomuhou.github.io/2024/03/20/skill/skill/","excerpt":"EVERYDAY速查总结一些小技巧总结，方便补充查阅","text":"EVERYDAY速查总结一些小技巧总结，方便补充查阅 罗马数字： 羅馬字 數字 羅馬字 數字 羅馬字 數字 羅馬字 數字 I 1 XI 11 XXI 21 C 100 II 2 XII 12 XXIX 29 CI 101 III 3 XIII 13 XXX 30 CC 200 IV 4 XIV 14 XL 40 D 500 V 5 XV 15 XLVIII 48 DC 600 VI 6 XVI 16 IL 49 CM 900 VII 7 XVII 17 L 50 M 1000 VIII 8 XVIII 18 LX 60 MDCLXVI 1666 IX 9 XIX 19 XC 90 MCMLXX 1970 X 10 XX 20 XCVIII 98 刚度矩阵提取： WB打开不显示： view-reset windows layout，显示前变形状态图 二力杆节点显示：搜索preference-勾选numbers nodes workb提取设置及流程： 软件中生成 point-genernate-line来自点-截面建立 mesh sizing-生成修改节点数量 输出结果中设置：求解方法solution-solver type-direct，analysis data-delete 非必要结构-no 导入APDL: analysis setting-advanced-:求解方法去掉分布式 读取-component-mechanical APDL模块-插入solution 更新 APDL read查看模态 file-list-binary-matrix-sys/mech/.ful文件选择stifness matrix，读取参数-转成txt 导入matlab文件转码(目前存在问题是，空间结构系统中自动生成的节点与理论节点数量有一定误差，这个后续解决来再补充，应该暂时不会再用到这个东西了) PS图片绘制设置(像)图片无损方法：图像大小-重新取样/邻近(赢边缘)宽高 变形方法： 滤镜液化 大小自定，压力25 冻结蒙版，压力100，眼睛下 转化成智能对象 视频帧转 像素前置设置 6464自订-拉入图片-窗口排列-双联垂直 视图-显示-像素网格 文件-存储为png 新建画布10，编辑-首选项-常规(邻近，非像素恢复 C+T放大) 视频剪辑 右键导入视频可以拆分轨道 去黑边方式-按住Crtl可以不锁定宽高比 缩略图全显示：选项-首选项-视频 Crtl+G时间点 反转-创建子剪辑 shift 工具多机位 先放大局部-导出视频-重新导入放大 抠图-视频色键 运动字幕-使用字幕与文字-文本后图标添加动画-出现关键帧 导出倍速视频：crtl按住视频边线：左加速右减速，直接拖边线不可以，只会恢复切片或者重复切片。 MATLAB 三维矢量图解组失败，一般是由于三维矢量图无法通过图窗复制-导出设置-渲染-printers对钩-应用复制图窗","categories":[],"tags":[]},{"title":"Silence","slug":"Silence/Silence","date":"2024-03-20T15:21:46.000Z","updated":"2024-03-20T15:24:43.227Z","comments":true,"path":"2024/03/20/Silence/Silence/","permalink":"http://xiaomuhou.github.io/2024/03/20/Silence/Silence/","excerpt":"沉默的大多数决定一切，当然也可能一点不重要","text":"沉默的大多数决定一切，当然也可能一点不重要 之前很喜欢一个民谣歌手，从崖边跌落开始入坑，最后听的是茶酒伴，再然后就听的少了许多，可能是因为随着年龄增长，越来越喜欢怀旧，容易留恋过去，导致对于新鲜的事物接受度越来越低，新出的歌听起来总是没什么感觉，看到歌手各种各样“叛逆”动态，心里想想开心就好，自己没啥资格留下对别人的评论，于是就沉默下来，每个人都是为自己活着，确实是自己开心就好。 不幸的是，现实里却常常事与愿违，面对上位压迫，往往还是会做出妥协，面对下位请求，则是做自己，这样的做法是否是真的做自己呢？印象里有一次评论区说一句喜欢过去的借我，春花发出近乎切割这首歌的言论，但是后来雷军转发，还是转的歌手原版本，春花也会出来营业，不知道那时候心里作何想法。 无意贬低任何人，只是在描述自己看到的一切，毕竟自己也是个俗人，在面对不影响自己太大利益的问题前，我会做到保持自我，开心就好，但是面对不可抵抗的问题，我也常常妥协，只是常常会思考，这个百分比占到多少才能算开心就好，坦然接受不纯粹，是不是也算？ 过去几年发生的很多事情改变了我很多对于这个世界的看法，依据不同的标准，就会做出不同的判断，以生死或者身边亲人朋友庞大的利益关系作为标准，沉默的大多数就不能被忽视，除非狠得下心放弃一切，所以最终大家都会成为俗人，只是没有被逼到那个程度（战争年代保有信仰的先辈是真的值得敬佩），这也是当今各种制度能够运行的基础，天下乌鸦一般黑，哪有绝对的是非对错，如果有，那只能是数学，但是这个世界又没有完全独立运转的事物，常常都是混杂在一起，所有常说难得糊涂，没有绝对的邪恶，只有正义的偏离。 言归正传，借用之前自己一句评论，朴树的歌能让我从难过变得平和，而春花的歌让我从平和到更加平和，未来依然会喜欢他们，但是也很好奇未来会是什么样子，毕竟很多老牌歌手几十年了还是被粉丝要求唱同一首歌，很喜欢观察完全不同生活的变化轨迹。 沉默、沉默，既要真实也要沉默，不带功利心的做一些事，人生才能持续下去…","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://xiaomuhou.github.io/tags/emo/"}]},{"title":"QT开发","slug":"QT开发/QT开发","date":"2024-03-03T14:16:57.000Z","updated":"2024-03-03T14:21:28.568Z","comments":true,"path":"2024/03/03/QT开发/QT开发/","permalink":"http://xiaomuhou.github.io/2024/03/03/QT%E5%BC%80%E5%8F%91/QT%E5%BC%80%E5%8F%91/","excerpt":"QT5开发总结空间XX优化开发界面-2024.2.5完成提交版 功能需求: 基于控制逻辑界面跳转 调用底层计算代码并优化 几个虚拟加载进度条 多阶输入读取及判断方式 总体：上位机需求功能比较简单，调用代码由于老师提供的底层的优化算法本身存在运行问题，导致一部分协调存在bug，因此整体功能存在问题，基本数据控制功能开发完成，已提交，暂时结束。","text":"QT5开发总结空间XX优化开发界面-2024.2.5完成提交版 功能需求: 基于控制逻辑界面跳转 调用底层计算代码并优化 几个虚拟加载进度条 多阶输入读取及判断方式 总体：上位机需求功能比较简单，调用代码由于老师提供的底层的优化算法本身存在运行问题，导致一部分协调存在bug，因此整体功能存在问题，基本数据控制功能开发完成，已提交，暂时结束。 1.跳转算法： 基于py的开发逻辑与C++一致，常见的几种，这里我使用的是按键检测，几个功能就写几个子界面，比较笨，但是容易理解，示例代码如下： 1234567from Ui_ST1_1 import Ui_Form1_1self.pushButton.clicked.connect(self.popWindow) #调用def popWindow(self):#定义 self.formZ=QtWidgets.QWidget() self.uiZ= Ui_Form1_1() #逻辑界面 self.uiZ.setupUi(self.formZ) self.formZ.show() 2.底层代码调用： abaqus子程序存在bug，这部分暂缺，后续如需要继续开发，代码修正后补充。 商业软件调用，写了一种基于subprocess调用外部EXE程序的方式，同样通过定义函数实现，注意一些小问题 123456789import subprocessself.pushButton_3.clicked.connect(self.open)#steupUIdef open(self): subprocess.Popen(r\"E:\\Program Files\\Inkscape\\bin\\inkscape.exe\")#这里注意一下python中的路径转义字符，要不就使用正斜杆，否则如上。#补充一个启动文件self.pushButton_2.clicked.connect(self.openFile)def openFile(self): directory1 = QFileDialog.getExistingDirectory(None, \"启动程序\",\"./\") print(directory1) 3.假装加载2333以及读取数据 读取doublespinbox与progressbar协调，延时用法以及其余读取代码句式参照那本书，边查边记。 12345678910111213141516valu = 1#定义初值self.pushButton_2.clicked.connect(self.va)def va(self):#点击执行只是循环一个功能，记住以后不要一个按钮对应多个按键，功能全部放在一起，执行顺序会有变化 for i in range(100): time.sleep(0.09) self.progressBar.setProperty(\"value\", i) valu=self.doubleSpinBox_4.value()#读取数据句式 print(valu) self.formZ=QtWidgets.QWidget() if valu==1: self.uiZ= Ui_Form2_3() else: self.uiZ= Ui_Form2_31() self.uiZ.setupUi(self.formZ) self.progressBar.setProperty(\"value\", 100) self.formZ.show() 4.图片读取流程，再次记录一下： QTcreator中构建资源库，在转成代码后进行转换运行，图片加载均通过UI端完成。 12pyrcc5 apprcc.qrc -o apprcc_re.py#转换pyinstaller -F -W XX.py#启动文件，其余控项可以看书 后续总结：希望早点把我的”雇佣兵”工资结了QAQ。 那本书多看看，后续完成底层代码的协调，以及一个上位机的编写，李工那边的火星车上位机，有空的话帮他了结一下。 学学特效，多看看语法书，慢慢牢固基础~","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/tags/note/"}]},{"title":"Q","slug":"Q/Q","date":"2024-02-26T15:11:26.000Z","updated":"2024-02-26T15:22:24.012Z","comments":true,"path":"2024/02/26/Q/Q/","permalink":"http://xiaomuhou.github.io/2024/02/26/Q/Q/","excerpt":"琥珀川与荻野千寻不乱于心，不困于情，不畏将来，不念过往。","text":"琥珀川与荻野千寻不乱于心，不困于情，不畏将来，不念过往。 看完之后脑子里立刻跳出来这句话。 又看了一遍台配版的千与千寻，童年的记忆来源于此版，有些东西确实只是忘记，而不会消失，偶然间看到一些痕迹，就会瞬间回忆，不过别回头就好，不念过往。 总是希望所有的一切事情按照自己的计划进行，面对未知的事情常常心怀恐惧而不愿意前进，权衡利弊之后，重要的事情可以克服，在一些小事上却常常让步，谓之不在意，其实不然，内心是在畏惧狭义上的未来，千寻初入汤屋有点这个感觉，但是随着故事的发展，千寻是做到不畏将来了，不论是给河神洗澡、给白龙和无脸怪吃河神的丸子，或者是爬梯子进入汤婆婆的房子，这些没有人给她指引，都是自己基于想法做出的选择，只要自己认为是对的，如果暂时判断不了，只要无愧于心，即使未来不可预测，脚踏实地的去做就很好，想必未来也不会后悔，不畏将来。 人生的环境总在不断变化，主动接受变化就是不畏将来，主动接受就不会恐惧，千寻开始的恐惧来源于被动，被动常常引起焦虑，负面情绪随之增长，以前很喜欢袁朗说的一句话：“不太焦虑，耐得住寂寞，有很多人天天都在焦虑，怕没得到，怕寂寞，我喜欢不焦虑的人”，千寻后来是不焦虑的，慢慢的去做事本身也是一种快乐的过程。 “容是别人，欲是自己”，去做一切自己想做的事情，少去思考虚无的无数可能性，不可预料的东西常常是惊喜，也是缘分。","categories":[{"name":"feeling","slug":"feeling","permalink":"http://xiaomuhou.github.io/categories/feeling/"}],"tags":[{"name":"movie","slug":"movie","permalink":"http://xiaomuhou.github.io/tags/movie/"}]},{"title":"start2024","slug":"start2024/start2024","date":"2024-02-19T12:07:04.000Z","updated":"2024-02-19T13:15:35.649Z","comments":true,"path":"2024/02/19/start2024/start2024/","permalink":"http://xiaomuhou.github.io/2024/02/19/start2024/start2024/","excerpt":"又是一年春距离上次笔记已有一年，没有做到经常写笔记，今年要改正，今天的目的是写一下总结以及对自己的要求，以及年后的一些规划， 几个指令备注一下： 1234hexo n \"学习笔记 六\"hexo dhexo cleanhexo g","text":"又是一年春距离上次笔记已有一年，没有做到经常写笔记，今年要改正，今天的目的是写一下总结以及对自己的要求，以及年后的一些规划， 几个指令备注一下： 1234hexo n \"学习笔记 六\"hexo dhexo cleanhexo g 总结过去的一年其实还不错，论文项目都有进度，但是后期又有点偷懒了，开年需要向后拓展，这部分已经总结过，简单略过。 预计要求过去的一段时间和很多人交流过，也一个人旅游过，发现自己还是有很多问题，认识自己，改正自己。 1.新的一年依然要强迫自己去做应该做的事情，见贤思齐，多多反省，心里逃避，但是还是要前进，太内向了确实不太好，应该多尝试主动与他人沟通，认识下总归没坏处。 2.新的一年接地气一点，不要太理性主义了，多多肯定别人的观点，别人的分享也要主动去看看，不要表现的不感兴趣，不要否定别人，少提意见，没有什么很俗的东西，生活就是这样，开心点，合群点。 3.与师长们相处，还是往常的态度就好，谦虚但是也要有自己的主见，这个去年大体上没有做错的地方。 4.生活上，过去的一年相对规律，新的一年依旧保持，但是之后的一段时间要去上一些强度。 年后规划1.学业部分不用讲，按照规律坚持就行 2.拓展一下爱好，旅游拍摄和像素画，要过得开心一点 自我评价内心依然有一些炫耀欲，与人相处很害怕别人把希望寄托在我身上，不想承担额外的责任。。。 沧浪之水，脚踏实地一点，多多与人沟通，人还是要接地气一点，虚荣驱动理想天天飘着，实际一点，开心一点。 补充一些博客修复内容：Permission denied (publickey) 没有权限的publickey ，出现这错误一般是以下两种原因 客户端与服务端未生成 ssh key客户端与服务端的ssh key不匹配找到问题的原因了，解决办法也就有了，重新生成一次ssh key ，服务端也重新配置一次即可。 ssh-keygen -t rsa -C “xx@qq.com” 然后再终端下执行命令： 1ssh -v git@github.com 最后两句会出现 1 No more authentication methods to try. Permission denied (publickey). 在终端再执行以下命令 1ssh-agent -s 接着在执行 1ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/id_rsa出现Could not open a connection to your authentication agent.这时可以使用：ssh-agent bash 命令，然后再次使用ssh-add ~/.ssh/id_rsa_name这个命令就没问题了。根据路径查看文件内部的命令： Identity added: …这是ssh key文件路径的信息 打开你刚刚生成的id_rsa.pub，将里面的内容复制，进入你的github账号，在settings下，SSH and GPG keys下new SSH key，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。 设置完成后 验证Key1ssh -T git@github.com 提示：Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/tags/emotion/"}]},{"title":"plan","slug":"plan/plan","date":"2023-01-29T13:39:11.000Z","updated":"2023-01-29T14:50:52.638Z","comments":true,"path":"2023/01/29/plan/plan/","permalink":"http://xiaomuhou.github.io/2023/01/29/plan/plan/","excerpt":"2023开学随笔","text":"2023开学随笔 说着要更新，但是因为各种各样的事情总是拖后，上个学期有了一些进度，但是后续仍然有很多需要落实的地方，今天顺便一起想了，生活上也有好多事情要处理，后天开学了，晚上闲来无事，大概想想~ 1.总的来讲，很多事进度没有严格按计划落实，还是个人惰性的问题，我自己一个人呆着的时候进度总是很慢，喜欢摸鱼，我打算严格落实目标，坚持完成。 2.有句话我觉得很有用-“你的人生没有那么多观众”，我现在已经可以下意识的做的一部分，但是还是没办法完全做到，不必强求吧，太过了可能也不好，对所有事都没兴趣，终归有问题，但是对一些没意义的事情，还是要避免，不去做没意义的事情；电话 会议？2333 3.开学之后是31，到元宵节，6天时间要加班把那个任务完成，最重要的一件事是每天也要坚持看英文文献，如果可以理解两个，把任务压缩到分配到每天，必须完成这些事情，然后汇报一下；这个是现阶段最最重要的事情 4.之前每天坚持落实的事情，要继续坚持下去，这个细规划吧； 5.生活上，过了个年胖了几斤，去了还是要规律饮食，坚持游泳，加油呀； 总结一下，落实进度，不要着急，行胜于言； 少说话，事情多做，多出自己的想法，多总结论文，多学习； 抵制下惰性，要努力呀； 有些话还想说，我觉得以后要果断一点，但前提是这半年要把目标落实了，很重要； 其余的生活规划放在后半年的时间里，总之脚踏实地，慢慢推进吧；","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"airfact","slug":"airfact","permalink":"http://xiaomuhou.github.io/tags/airfact/"}]},{"title":"newnote","slug":"newnote/newnote","date":"2022-08-02T04:20:38.000Z","updated":"2022-08-02T04:23:39.493Z","comments":true,"path":"2022/08/02/newnote/newnote/","permalink":"http://xiaomuhou.github.io/2022/08/02/newnote/newnote/","excerpt":"又要重新开始更新啦，人生很难，总要继续，接下来会好好在这个无人知晓的角落记录我的人生，加油","text":"又要重新开始更新啦，人生很难，总要继续，接下来会好好在这个无人知晓的角落记录我的人生，加油","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"airfact","slug":"airfact","permalink":"http://xiaomuhou.github.io/tags/airfact/"}]},{"title":"","slug":"life/life","date":"2022-08-02T04:12:04.445Z","updated":"2020-12-14T13:48:20.286Z","comments":true,"path":"2022/08/02/life/life/","permalink":"http://xiaomuhou.github.io/2022/08/02/life/life/","excerpt":"","text":"怎么会迷上你，我在问自己 我什么都能放弃，居然今天难离去 我是个什么人呢？ 乐观、向上、热心又冷漠 犹豫、常常忽略一些事情、讨厌很多事情 一个半吊子的理想主义者～ r","categories":[],"tags":[]},{"title":"Quaternion","slug":"Quaternion/Quaternion","date":"2021-11-24T13:32:57.000Z","updated":"2021-11-24T13:41:56.087Z","comments":true,"path":"2021/11/24/Quaternion/Quaternion/","permalink":"http://xiaomuhou.github.io/2021/11/24/Quaternion/Quaternion/","excerpt":"万向锁问题造成影响：出现万向锁后会丢失自由度","text":"万向锁问题造成影响：出现万向锁后会丢失自由度 从结构角度分析：主要原因是由于各旋转轴之间存在运动关系，即动态欧拉角，角度变化后，坐标系随之发生变化，比如万向锁结构，三个坐标轴分别可以用环结构表示，外环、中环、内环，当内环转动，即等效沿某一轴转动，内环与中、外环都存在运动关系，坐标系同时变化，就不会发生重叠现象，；当中环运动时，内环不会运动，只有外环会进行运动，那么内环所代表的坐标系可能会与外环所代表的坐标系重合，当进行动态旋转时，沿着外环与内环代表的坐标系运动，只会产生一个方向的自由度，由此发生了万向锁现象，即丢失一个自由度。 后续一些想法看b站评论说为什么不选取惯性坐标系作为参考运动，这样就不会出现万向锁现象了？ 其实这是一个概念的问题，首先需要理解欧拉角的意义，欧拉角是用来描述姿态的三个角度，包含静态、动态两种，静态欧拉角即沿着惯性坐标系进行运动，而动态欧拉角则会出现万向锁现象，动态有12种旋转方式，XYZ、XZY、XYX、XZX、YXZ、YZX、YXY、YZY、ZXY、ZYX、ZXZ、ZYZ,含有中间轴Y都存在万向锁问题。 因此该问题的本质是动态欧拉角的意义是什么？ 基于动态坐标的欧拉角旋转，其惯性张量不随着时间改变而改变，将其进行对角化处理，即可以得到一个一组主轴和一个只含三个分量的主动惯量，动力学计算较为容易，这一部分内容可以机器人动力学模型计算案例中深入理解。 四元数为了描述复杂运动以及规避一些特殊点，可以用四元数工具进行描述分析，最近正在整理旋量与四元数的并联应用分析内容，以后会写一个小总结。","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"mathematica","slug":"mathematica","permalink":"http://xiaomuhou.github.io/tags/mathematica/"}]},{"title":"note","slug":"note/note","date":"2021-09-10T13:14:00.000Z","updated":"2021-10-08T12:00:22.596Z","comments":true,"path":"2021/09/10/note/note/","permalink":"http://xiaomuhou.github.io/2021/09/10/note/note/","excerpt":"常用的几个latex图片框架以及公式","text":"常用的几个latex图片框架以及公式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546常用补充公式备注\\begin{tabularx}{\\textwidth}{@{}l@{\\quad}r@{———}X@{}} 式中&amp; $C_{D, i}$&amp;表示阻力系数，数值可根据表xx查询确定 \\\\ \\end{tabularx}\\vspace{3.15bp} 图片备注\\begin{figure}[!h] \\setlength{\\subfigcapskip}{-1bp} \\centering \\begin{minipage}{\\textwidth} \\centering \\subfigure{\\label{a}}\\addtocounter{subfigure}{-2} \\subfigure{\\subfigure[R=80mm]{\\includegraphics[width=0.25\\textwidth]{80}}} \\hspace{1em} \\subfigure{\\label{b}}\\addtocounter{subfigure}{-2} \\subfigure{\\subfigure[R=90mm]{\\includegraphics[width=0.25\\textwidth]{90}}} \\hspace{1em} \\end{minipage} \\vspace{0.2em} \\caption{不同静平台半径机构条件数分布图}\\end{figure}\\begin{figure}[htbp] \\centering \\begin{minipage}[t]{0.4\\textwidth} \\centering \\includegraphics[width=\\textwidth]{431} \\caption{静平台坐标系} \\end{minipage} \\centering \\begin{minipage}[t]{0.4\\textwidth} \\centering \\includegraphics[width=\\textwidth]{432} \\caption{动平台坐标系} \\end{minipage} \\centering \\begin{minipage}[t]{0.8\\textwidth} \\centering \\includegraphics[width=\\textwidth]{45} \\caption{等效四面体示意图} \\end{minipage}\\end{figure} 无用 结构紧凑，速度响应更快，定位精度更高，刚度更高，负载支持更好，动态性能更好，功耗更低 可以将辐射引起的力和力矩确定为三个新分量的总和： （1）由于周围流体的惯性而增加的质量 （2）由于产生的表面波带走的能量而引起的辐射诱导的电位阻尼 。 （3）由于阿基米德（重量和浮力）而恢复。","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"formula","slug":"formula","permalink":"http://xiaomuhou.github.io/tags/formula/"}]},{"title":"gcyyy","slug":"gcyyy/gcyyy","date":"2021-09-10T13:10:14.000Z","updated":"2021-09-10T13:35:45.132Z","comments":true,"path":"2021/09/10/gcyyy/gcyyy/","permalink":"http://xiaomuhou.github.io/2021/09/10/gcyyy/gcyyy/","excerpt":"并联机构弹性动力学建模与振动主动控制论文2021.9.8 并联机器人高维运动规划研究—刚柔耦合非线性力学—————-形变+运动规划————非线性数学模型—————-弹性运动规划算法 无碰撞未超过运动规划极限—自由位形 （缺少论文整理部分）","text":"并联机构弹性动力学建模与振动主动控制论文2021.9.8 并联机器人高维运动规划研究—刚柔耦合非线性力学—————-形变+运动规划————非线性数学模型—————-弹性运动规划算法 无碰撞未超过运动规划极限—自由位形 （缺少论文整理部分） 特殊规划-路径无奇异且路径具备刚度与精度 弹性路径数学模型—内力与内力矩微分方程传递性，作用于整条路径，外部不具有传递性，只发生于作用点。 本构模型—-激励与响应的关系 路径形变控制机理 子任务内容：耦合作用机理、弹性运动模型、运动控制反解模型 联合运动：动舵/直接力复合控制的难点在于如何有效、快速地融合气动舵的连续输出与直接力的离散输出。传统的优化融合策略需在每个控制周期内求解最优分配问题，这将消耗大量的机载计算资源。 问题：非线性弹性动力模型建立不够清晰 来源：TUOsd_cjm 动力模型过程清晰，验证存在一定疑问 3RRR构型 柔性机器人-造价低、操作速度快、驱动力小、能耗低、良好的机动性能、安全性高 关键词：并联、刚柔耦合动力学、振动抑制 杆件关节变形能 柔性机器人动力学方程—多自由度偏微分方程—有限维常微分方程近似替代 连续系统离散化处理—-假设模态法AMM、有限元方法FEM、集中参数法IPM。 记录一下小概念 动力学方程：研究力和位移或力矩和转角的关系 获得描述广义坐标随时间变化的闭环方程——-牛顿拉格朗日 给定广义坐标后，需要给系统多大的广义力，可以实现预期的广义坐标轨迹———-牛顿欧拉 动力学建模方法：笛卡尔坐标、关节坐标、动力学样条法、波方法，李群李代数。 柔性机器人振动控制： 被动控制： 优化构件截面参数及几何参数 复合材料替代金属材料 阻尼处理构件—减振 主动控制： 传感器与作动器 设计多个可控原动件的受控机构 基于动力模型的控制系统 压电陶瓷片 压电陶瓷驱动器相关应用：压电驱动器绑定在弹性结构表面或嵌入压层复合材料中Edward 柔性机器人研究包含毂-两结构、柔性两杆和四杆机构，对于柔性并联研究较少。 质量、运动轨迹导致各关节驱动力矩和能耗差别很大 柔性机器人动力学特性分析内容频率特性分析、灵敏度分析、模态分析、动应力分析 系统弹性振动主要有低阶模态决定，固有频率越低，系统刚度越小，越容易振动 两步法：KED假设弹性变形位移是小的，忽略弹性变形对于刚体运动的影响，建立系统刚体动力学方程，将运动学变量带入弹性变形运动动力学方程。 一步法：考虑刚体运动与弹性变形运动耦合，更精确的模型求解方法 力热固耦合弹性动力学（一致温度）基于有限元方法和Hamilton原理 建立单元弹性动力学模型，假设热载荷导致机构产生的变形量与应力导致的变形线性且各向同性，建立联立应变方程。 基于ANSYS瞬态动力学仿真，计算了主动关节和被动关节没有热载荷和多种温度下最大等效应力图 记录了多地温度变化曲线，测量连杆最大等效应力随时间的变化关系 结论：温度变化，最大等效应力保持周期性上升；气温不变，最大等效应力保持周期性稳定。 温度高低不是决定因素，温差大小决定应力变化 柔性并联机器人的动态性能不仅与温度该改变量大小和材料的温度膨胀系数有关，而且与温度变化曲线也密切相关。 文章通过气象台的温度数据，导入CFD软件中，进行瞬态动力学分析，得到应力变化图，进而分析温度关系，还是没能给出一个直接的解析式呀，复杂机构的耦合动力学模型建模还是一个难解。 弹性动力学的动力钢化问题高速、高加速柔性并联机器人是否存在动力钢化现象。 单元—系统 一阶近似耦合模型FOAC:包含名义运动相关的动力刚度项 传统混合坐标建模方法 ZOAC：无法很好的反应系统的动力学性能，假设轴向与横向变形位移解耦。适用于并联机构 无论系统运动速度、加速度多大，系统刚度项对系统动力学特性影响微小。 执行机构动力学模型建立结束，基于模型的振动控制 主动振动控制研究控制目的：抑制并联机器人柔性连杆的残余振动，保证动平台精确地到达给定的位姿。 PZT压电驱动器作用机理：给驱动器施加电压信号，PZT驱动器产生应变，在驱动器两端，这种应变将在梁单元对应的位置上引起剪切变形 通过驱动器对梁单元施加外力矩 控制器优化方向-能量优化，在更低的控制电压下可以取得更好的控制效果。一对PZT控制效果优于一片。 控制内容后续完善 结论：单独控制柔性杆时，可以抑制自身的弹性振动，无法控制其他两柔性杆振动，当三根杆同时振动时，各柔性杆的弹性振动都能得到很好的抑制。 平台质量和运动轨迹对驱动能耗有直接影响。——- 轻量化设计以及轨迹规划内容，不过这篇文章感觉这部分写不了啥论文 建立并联机器人刚柔耦合非线性动力学方程 构件弹性变形与刚体运动之间互相耦合影响 感觉压电陶瓷驱动器抑振是文章最重要的点。 文章方向整理：","categories":[{"name":"project","slug":"project","permalink":"http://xiaomuhou.github.io/categories/project/"}],"tags":[]},{"title":"DOC_exercise","slug":"DOC-exercise/DOC-exercise","date":"2021-08-29T07:03:34.000Z","updated":"2021-08-29T08:51:01.591Z","comments":true,"path":"2021/08/29/DOC-exercise/DOC-exercise/","permalink":"http://xiaomuhou.github.io/2021/08/29/DOC-exercise/DOC-exercise/","excerpt":"随笔加一些更新计划人生不长，总归还是想做一些有意义的事情——-这是一切的出发点","text":"随笔加一些更新计划人生不长，总归还是想做一些有意义的事情——-这是一切的出发点 更新计划之后会更新一些视频与博客，博客文案，视频过程，在记录的同时巩固自己，希望可以帮助到一些朋友，要更新一些硬货，2333 1.专业相关内容的研究，根据情况落实 2.ROS、模拟软件以及一些算法记录过程 3.游戏历史考据，比方说最近想得是重装的怪物史，总不可能是凭空出现的，回忆下过去，开拓下视野。 4.文学方面的内容，提高一下，没想好更新什么，以后慢慢来 一些需要时刻记住的事情行甚于言，很重要的一点； 前段时间总是自我怀疑，希望不要忘记自己的初心，我还是有一些优点的，踏踏实实的做事就好； 操千曲而后晓声，观千剑而后识器，大量且规律的积累是以后必须做到的； 要努力提高英语呀，坚持日积月累； 拓展视野，坚实基础；保持信心，提高自己； 去做一些更好玩的事情，记住自己的初心，坚持下去（已经确确实实是个成年人了，以后要更成熟一点） 未来很精彩，坚持自己，去看看更大的世界，变成一个更好的人","categories":[],"tags":[{"name":"plan","slug":"plan","permalink":"http://xiaomuhou.github.io/tags/plan/"}]},{"title":"plan_emotion","slug":"plan-emotion/plan-emotion","date":"2021-08-26T02:17:02.000Z","updated":"2021-08-26T03:15:40.286Z","comments":true,"path":"2021/08/26/plan-emotion/plan-emotion/","permalink":"http://xiaomuhou.github.io/2021/08/26/plan-emotion/plan-emotion/","excerpt":"Ubuntu修复windows无法启动问题","text":"Ubuntu修复windows无法启动问题 配置：ubuntu16.04+windows8.1 背景：电脑不小心被砸了一下，然后windows系统无法启动，也无法进入bios和安全模式，尝试启动Ubuntu系统，发现可以进入，Linux永远的神！！ linux端进入后，发现电脑系统盘无法读取，出现挂载错误，可能windows就是因为这个问题无法启动，尝试修复，记录一下最后有效的过程： 1.查看系统下所有分区的挂载情况是否正常1sudo fdisk -l 根据×号判断 2.修复对应分区，我显示的是/dev/sdb31sudo ntfsfix /dev/sdb3 全部修复后，windows可以正常启动 以后正常更新啦… 等会儿再写一个生活计划日志…","categories":[],"tags":[]},{"title":"fluid_model","slug":"fluid-model/fluid-model","date":"2021-02-03T03:05:30.000Z","updated":"2021-02-03T03:07:58.678Z","comments":true,"path":"2021/02/03/fluid-model/fluid-model/","permalink":"http://xiaomuhou.github.io/2021/02/03/fluid-model/fluid-model/","excerpt":"流体相关开个坑，后续补充","text":"流体相关开个坑，后续补充 运动阻力与速度平方成正比 阻力与流体密度成正比，水中和空气中阻力系数同一量级，但是水的密度是空气的800倍","categories":[{"name":"learning","slug":"learning","permalink":"http://xiaomuhou.github.io/categories/learning/"}],"tags":[]},{"title":"ff14宏","slug":"ff14宏/ff14宏","date":"2021-02-03T03:01:00.000Z","updated":"2021-02-03T03:04:37.477Z","comments":true,"path":"2021/02/03/ff14宏/ff14宏/","permalink":"http://xiaomuhou.github.io/2021/02/03/ff14%E5%AE%8F/ff14%E5%AE%8F/","excerpt":"ff14宏学相关记录一下常用宏，方便玩游戏 资料来源：ff14wiki、素素","text":"ff14宏学相关记录一下常用宏，方便玩游戏 资料来源：ff14wiki、素素 代名词 解释 当前选中目标的名字 当前选中目标的选中目标的名字 自己的名字 &lt;1~8&gt; 队伍列表中对应编号的人的名字 焦点目标的名字 上个选中的目标的名字 上个选中的敌人的名字(当你的当前目标是敌人时，会显示你的当前目标) 上个对自己造成伤害的敌人的名字 自己的陆行鸟的名字 自己的召唤物的名字 自己的当前坐标，可以被点击插旗 当前插旗地点的坐标，可以被别人点击插旗 当前鼠标指向的目标的名字，指向小队列表/仇恨列表/目标模型都算。手柄注意：手柄的预选中状态不算 最近选择过“展示道具属性”的道具链接。装备上的魔晶石、签名、精炼度、耐久等全部不能正确显示，只能显示基本属性 指定技能的剩余冷却时间，格式为—:—(分:秒)，因此不能用来作为wait的时间参数。已冷却完毕的技能会显示为—:—。只有当前职业的技能可以被正确显示，并且不能用定型文。 被标记了“攻击1~5”记号的单位的名字，同理还有，，等。 上一个悄悄话你的人的名字 自己的当前hp值/最大hp值，同理还有(魔力)、(你的陆行鸟hp) 自己的当前hp百分比，同理还有、、(当前选中目标)、(焦点目标) 自己的当前职业(等级)，同理还有(当前选中目标)、(焦点目标) 群狼盛宴专用，直接指代对方1-4号 ：等同于/wait X，在发言中使用不会在发言中显示，但同一排后面的内容会消失，具体说明见下文。 ：发出提示音，只在小队/团队/默语频道有效果。可以认为是指代了一个本来不能用语言描述的“声音”，会显示在发言中。 例子 释放指定地面目标的能力技，这样可以省去点击地面的时间，但是有些情况下不能灵活的调整放置的地点。 /ac 野战治疗阵 释放非战斗职业的技能，比如一键生产宏，一键精选宏。(生产职业所有制作、加工、观察、专家技能后wait3，松弛、其他buff技能后wait2，采集职业精选buff技能后wait1，甄别技能后wait3，若网络条件不佳，可适当延长)优先级的思想同样适用(主要针对秘诀、集中加工、审美眼等)。 /ac 审美眼 /ac 直觉甄别 /ac 审美眼/ac 聚精会神 /ac 直觉甄别 /ac 审美眼/ac 聚精会神 /ac 慎重甄别 在发动技能后等待一段时间喊话提示，如无敌。 /ac 神圣领域/p 我已经天下无敌了！！！/wait 10/p 停一停奶妈快爱我！！！ [进阶向]在生产宏中打时间差，实现5仓促中任换至多一个为集中加工一类的高级功能 /ac 集中加工 /ac 仓促 /ac 仓促 /ac 集中加工 /ac 仓促 /ac 仓促 /ac 集中加工 /ac 仓促 /ac 仓促 /ac 集中加工 /ac 仓促 /ac 仓促 /ac 集中加工/ac 加工 文本指令 对应频道及说明 /s 说话频道，可见范围比较小，对连续发言有限制——大约在0.76s-1s内只能在该频道说一句话，多的会被吞掉——其他玩家看不到，但是系统仍然认为你说了这句话，任务要求说话的能被成功判定。例如： /s 1111111111 /s 有库啵果哦 /s 线轴 /s 展翅高飞 /s 乌姆·阿拉 /s 乘风而起 后面五行都不会被其他玩家看见。/s的上屏延迟大约是0.16s，一句话可以压掉下面五句话。 /em 情感动作频道，和说话频道基本相同，ID和内容之间没有冒号。限制连续发言——尽管你在连续发言时不会收到系统提示。 /y 呼喊频道，可见范围比说话频道大一些，对连续发言有限制 /sh 喊话频道，该地图内全屏可见，对连续发言有限制，se提示音没有效果 请不要再试图在报点宏上加声音了 /tell 悄悄话频道，格式/tell 人物名@服务器名(同服省略) 内容，对连续发言有限制，省略内容将改变悄悄话默认目标 /reply 悄悄话频道，送信目标为上一个给你发悄悄话人，不会因为下线而消除 /p 小队频道，不限制连续发言，se提示音有效 /a 团队频道，不限制连续发言，se提示音有效 /fc 部队频道，不限制连续发言 /pvpteam 战队频道， 我还没有 /cwlx 跨服通讯贝频道，x为通讯贝编号，省略则为最近一个激活的通讯贝——最近一个激活可以是用指令发言(未切换频道)或者主动切换默认频道(不管有没有发言)，省略内容将改变默认频道，不限制连续发言 /lx 通讯贝频道，x为通讯贝编号，省略则为最近一个激活的通讯贝——最近一个激活可以是用指令发言(未切换频道)或者主动切换默认频道(不管有没有发言)，省略内容将改变默认频道，不限制连续发言 /b 新人频道， 不好意思在里面测试 /e 默语频道，仅自己可见，发送速度比其他频道都快得多，se提示音有效 /cth 清除悄悄话记录，清除的实际上是曾悄悄话过的对象而不是悄悄话内容 /cl 清空聊天窗口的所有信息 宏专用文本指令标准格式/micon 图标名 分类名","categories":[{"name":"game","slug":"game","permalink":"http://xiaomuhou.github.io/categories/game/"}],"tags":[]},{"title":"impedance_control","slug":"impedance-control/impedance-control","date":"2021-02-03T02:58:44.000Z","updated":"2021-10-08T12:00:23.164Z","comments":true,"path":"2021/02/03/impedance-control/impedance-control/","permalink":"http://xiaomuhou.github.io/2021/02/03/impedance-control/impedance-control/","excerpt":"阻抗相关记录部分内容","text":"阻抗相关记录部分内容 人机协作协作定义：协作参与方具备共同目标、具备感知交流能力、协同能力 标准：安全、协作、智能 交互控制-力控制直接力控直接设定数值，通过反馈进行精确设定控制 1.成本高、精度差、存在噪声、干扰难以判断 2.无法确定具体所需控制数值 间接控制柔顺控制被动柔顺：通过含有弹性元件的机械设备在接触过程中体现柔顺 主动柔顺：通过控制的方式实现，越位设置，在接触过程中产生作用 阻抗/导纳控制：关节空间 笛卡尔空间：常用 力/位混合控制关节空间阻抗控制阻尼：抵消机械震荡 弹性元件：柔顺性调整 控制理论 阻抗控制主要是控制运动与力之间的动态关系控制 实现理想阻抗控制需要满足： 1.机器人动态模型及相关参数 2.机器人关节角、关节角速度的实时反馈（传感器） 3.机器人关节力矩实时反馈（转矩传感器获得/测量驱动电机电流，通过电流关系进行计算分析） 4.机器人转矩控制 设定k值 k大—抵抗性较强 k小—柔顺性较高 k=0，随外力改变位置 笛卡尔关节控制1.求解雅克比（伪）逆矩阵，以及雅克比矩阵导数矩阵 2.精确测量机器人执行器末端所受外力 3.精确的机器人运动学以及动力学模型 4.机器人关节位置及转速的测量 5.机器人关节转矩控制 姿态不要过度接近奇异点 控制机器人运动与外力之间的动态关系，使其等效为弹簧-阻尼-质量组成的二阶系统 需要条件 1.机器人动力学及运动学模型 2.关节角及角速度反馈 3.关节转矩控制 4.外力（矩）的测量（非必要） 导纳控制与阻抗控制区别 1.计算出力，控制器输入位置输出力 2.控制器输入力输出位置，机器人输入位移输出力 当外界环境阻抗系数高，采用阻抗控制 当外界环境阻抗系数低，采用导纳控制？？ 导纳控制有点像变刚度控制，区分并进行理解。 自适应阻抗控制自主调整阻抗，满足环境要求 1.自主目标 阻抗系数或者运动设定 2.如何实现参数修改 基准：保证机器人稳定性 一些例子 1.根据外力反馈调整阻尼系数，预测运动意图 2.稳定性分析 3.估算人的阻抗系数 力增大-意图为该方向加速-机器人减小阻抗系数以顺应需求-减小接触力，反之亦然 思路可以换一下，外力作为负反馈进行相应调节 阻抗模型 水的阻抗模型？？？ 参数辨识法 通过速度反馈调节参数进行示教学习 提高舒适跟随 根据实验进行确定稳定区域模型而非理论推导—不严谨但是更贴近实际 1.基于可操作性 2.基于阻抗控制误差 三. 1.多传感器融合，建立手臂运动中 姿态以及肌肉信号实时反馈 2.基于机电信息，建立手臂阻抗模型，并调整机器的阻抗系数 3.力/阻抗混合控制 肌肉电信号EMG使用方法 optitrack 视觉信息使用 该方案中捕捉手臂姿态的变化，根据姿态变化调整机器人阻抗系数在空间上的分布 力传感器 机械臂末端 四 1.基于视觉信息，利用高斯过程回归，在线预测人运动轨迹，评估预测不确定性 2.基于预测结果，调整机器人运动 3.利用阻抗控制跟随设定轨迹，同时改变参数大小，保证safe 强化学习阻抗控制引入强化学习 学习力场？？？？学习一下 强化学习是机器学习的一个领域，强调如何基于换将反馈而行动，已取得最大化的预期利益。 寻找最优策略，使得价值函数最大 1.基于模型的强化学习 需要建立模型 2.基于价值函数的强化学习 根据价值调整策略 3.基于策略函数的强化学习 不依赖于模型 缺点 ：收敛慢、可能会到达危险状态、 原因： 1.建模较为困难 2.机器人可以不断优化自身行为，理论上可以得到最优解 核心; 求解问题： 1.基于价值函数 2.基于神经网络的Actor-critic算法 3.策略迭代 策略 —-如何保障安全性 基于价值函数的强化学习 1.定义人机协作最优控制问题，基于Q-leaning设计自适应阻抗 2.利用人和机器人的阻抗模型及线性回归的方法估测人的示教轨迹 自适应阻抗学习时间最小，同时保证了一定时间 基于策略函数的强化学习 价值 理论完整，可以达到全局最优 实现简单，收敛较快 缺点：维数灾难，控制策略会受到函数近似误差影响 策略 不存在维数灾难 理论上只能局部最优，收敛较慢 案例分析 1.基于策略函数的强化学习算法 2.运用于机器人的自适应阻抗中，并在不同平台测试 机器人仅在任务需要时候保证高阻抗，其余保证低阻抗 目前问题：有些不可达到的点集成于学习过程中，进行处理 强化学习应用于控制理论阶段 1.机器人动力学参数辨识 2.关节摩擦力的建模和补偿 3.基于电流环或关节转矩测量外力估算 4.阻抗系数矩阵非对角元素设计 方向 1.基于多传感器多信息融合的自适应阻抗控制 2.与人工智能相关技术结合 3.基于强化学习的阻抗控制 与基于模型的最优控制结合（发挥各自有点） 状态约束和稳定性分析 基于策略搜索的强化学习","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[{"name":"control","slug":"control","permalink":"http://xiaomuhou.github.io/tags/control/"}]},{"title":"记录","slug":"记录/记录","date":"2021-01-06T13:58:11.000Z","updated":"2021-02-03T02:51:11.124Z","comments":true,"path":"2021/01/06/记录/记录/","permalink":"http://xiaomuhou.github.io/2021/01/06/%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95/","excerpt":"会议记录学习，学习一下","text":"会议记录学习，学习一下 human-like，行为传递 接触性作业—需要涉及force control 阻抗控制 刚度无法直接测量—机电信号与刚度信号 类人控制从两方面思考 1.控制器 2.操作 敲钉子—固定位置，但是又不可以握紧，松一点反而方便操作 对刚度矩阵进行操作，控制 接触力与刚度 刚度不变，改变接触力；接触力基本不变改变刚度 控制模型（学习模型） 对干扰方向增加刚度，其余方向保持柔顺， 变刚度控制—保证精确控制 其余应用： 人机协同领域：根据人力改变刚度，比如锯木头案例 机器人与环境交互 一项思考，针对水阻力进行变刚度控制，是否能实现精确位置控制，抵抗阻力呢，可以尝试·· 2011文章 分布于力场中的机构，运动，未知力场（流体力场？）保证机器人进行直线运动，进行轨迹规划，可以借鉴，论文 如何分析力场？神经网络学习力场 增量学习法控制器，是机械臂沿直线运动，学习之后进行目标运动 示教学习 c.yang ieee tll 2018 泛化—分割 大多考虑运动控制，考虑力控制，才能实现精确作业 通过机械脉冲，测量刚度 基于IMUs和ARM model测量 力、刚度stiffness、位置控制 遥操作相关特殊环境通信？？ 避障—机器人建模 了解一下 MYO armhand 双臂操作 控制小车 利用操作杆 控制小车 优点：手环只有视觉效果，这里是否可以应用于目前手机厂商的手环产品上呢？可以尝试一下 操作杆：可以有力反馈 虚拟环境力反馈，模仿了人类的视角作业 12.30 — 20.30 增量学习-鲁棒项 希望实现全局稳定—当运动范围过大时，加入鲁棒项进行回收。 学习外界环境 力场，不考虑机构本身，利用机构本身控制模型去学习外场，这样是否可以在动力模型不引入外阻力项，仅仅通过外刚度变化控制，实现对于未知力场学习后，进行精确轨迹路线的规划。 示教学习是一个良好的方向 云服务应用于示教学习，案例共享。 组装工序 LQR线性模型学习人体阻抗模型 保持本身—外部环境隔开-学习外部环境 机电信号测量刚度—-匹配刚度矩阵— 长时间泛化 误差累积和噪声累积 RBF神经网络学习 扩大范围，进行控制覆盖，建立地图。 神经网络用于提高性能，优化 稳定利用传统控制方法进行稳定 一对多控制 emgsensor 8通道","categories":[],"tags":[]},{"title":"ros问题总结","slug":"ros问题总结/ros问题总结","date":"2021-01-05T14:03:12.000Z","updated":"2021-02-03T02:49:49.464Z","comments":true,"path":"2021/01/05/ros问题总结/ros问题总结/","permalink":"http://xiaomuhou.github.io/2021/01/05/ros%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/ros%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"常见问题总结","text":"常见问题总结 缺少cmake文件，安装方式提示 xxConfig.cmake 找不到 查找上一行 …provided by “xx” 补充 sudo apt-get install ros-ROS版本-xx roscore运行出错 Unable to contact my own server a xiaomu@GL:~$ export ROS_HOSTNAME=localhostxiaomu@GL:~$ export ROS_MASTER_URI=http://localhost:11311 Unable to contact my own server at [http://192.168.0.106:35623/]. This usually means that the network is not configured properly. A common cause is that the machine cannot connect to itself. Please checkfor errors by running: ping 192.168.0.106 For more tips, please see http://www.ros.org/wiki/ROS/NetworkSetup 修正： $ export ROS_HOSTNAME=localhost $ export ROS_MASTER_URI=http://localhost:11311","categories":[],"tags":[]},{"title":"c++_qt_note","slug":"c-qt-note/c-qt-note","date":"2020-12-14T13:24:42.000Z","updated":"2021-01-01T12:39:29.616Z","comments":true,"path":"2020/12/14/c-qt-note/c-qt-note/","permalink":"http://xiaomuhou.github.io/2020/12/14/c-qt-note/c-qt-note/","excerpt":"c++与QT学习记录给李工干项目涉及到相关知识，终究躲不过c艹，开个帖子记录学习，方便查询相关 FF","text":"c++与QT学习记录给李工干项目涉及到相关知识，终究躲不过c艹，开个帖子记录学习，方便查询相关 FF 资料来源 C++：http://c.biancheng.net/cplus/ QT：http://c.biancheng.net/qt/ // QT官方教程 快捷键记录 1）帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法） 2）.h 文件和对应.cpp 文件切换：F4 3）编译并运行：Ctrl + R 4）函数声明和定义(函数调用和定义)切换：F2 5）代码注释取消注释：Ctrl + / （选中代码再按快捷键） 6）字体变大变小：Ctrl + 鼠标滚轮向上向下 7）移动代码：选中所要移动的代码 -&gt; 按住 ctrl + shift -&gt; 键盘方向键 8）查找替换关键字：Ctrl + F 9）快速打开代码所在目录：编辑模式下 -&gt; 选中项目文件 -&gt; 右击 -&gt; 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录） 关于语言相关资料来源https://wizardforcel.gitbooks.io/wudi-qt4/content/19.html linux常用指令 man 获得联机帮助，是类 Unix 用户的在线帮助手册 cd 切换当前路径命令 pwd 显示当前路径 ls 显示目录下面的文件和子目录情况 chmod 变更文件和目录的属性 mkdir 建立目录 rm 删除目录或文件 su 切换用户登录到 shell，常见从一般用户到 root 用户或者相反顺序 exec 执行程序，并且不返回到当前 shell ldd 查看应用程序使用的动态库 nm 查看程序或库的调试信息 objdump 查看程序或库的信息 env 查看环境变量 grep 从文件中查找字符串 find 查找文件 which 查找命令的可执行文件 uname 查看操作系统版本 ps 查看进程信息 top 查看系统资源信息 vmstat 查看系统虚拟机各资源信息 vi/vim 使用 vi/vim 编辑器 make 处理工程文件，生成可执行文件或库或其他资源文件 gdb/dbx 调试工具命令 strace/ltrace 跟踪程序调用的系统函数情况 file 查看文件的格式 fuser 查看进程使用了哪些文件 关于各个文件配合关系—距离说明 .h 定义窗体类的头文件，定义了类Widget .cpp Widget 类的功能实现源程序文件 .ui 窗体界面文件，由UI设计器自动生成，存储了窗体上各个组件的属性设置和布局 ui_widget.h 编译后，根据窗体上的组件及其属性、信号与槽的关联等自动生成的一个类的定义文件，类的名称是Ui_Widget UI布局 布局组件 功能 Vertical Layout 垂直方向布局，组件自动在垂直方向上分布 Horizontal Layout 水平方向布局，组件自动在水平方向上分布 Grid Layout 网格状布局，网状布局大小改变时，每个网格的大小都改变 Form Layout 窗体布局，与网格状布局类似，但是只有最右侧的一列网格会改变大小 Horizontal Spacer 一个用于水平分隔的空格 Vertical Spacer 一个用于垂直分隔的空格 快捷键查询 按钮及快捷键 功能 Edit Widget (F3) 界面设计进入编辑状态，就是正常的设计状态 Edit Signals/Slots(F4) 进入信号与槽的可视化设计状态 Edit Buddies 进入伙伴关系编辑状态，可以设置一个Label 与一个组件成为伙伴关系 Edit Tab Order 进入Tab 顺序编辑状态，Tab 顺序是在键盘上按Tab 键时，输入焦点在界面各组件之间跳动的顺序 Lay Out Horizontally (Ctrl+H) 将窗体上所选组件水平布局 Lay Out Vertically (Ctrl+L) 将窗体上所选组件垂直布局 Lay Out Horizontally in Splitter 将窗体上所选组件用一个分割条进行水平分割布局 Lay Out Vertically in Splitter 将窗体上所选组件用一个分割条进行垂直分割布局 Lay Out in a Form Layout 将窗体上所选组件按窗体布局 Lay Out in a Grid 将窗体上所选组件网格布局 Break Layout 解除窗体上所选组件的布局，也就是打散现有的布局 Adjust Size(Ctrl+J) 自动调整所选组件的大小 项目功能实现ui_xxx.h 文件查看 crtl在头文件查询 资料来源 https://blog.csdn.net/modi000/article/details/107550427 关于使用designer ui编写c++第二种方法相对比较简单一点，就是将Ui::Dialog ui或Ui::Dialog ui写成一个新定义类的一个数据成员，也就是qtcreator提供的那种方法。（也叫*单继承方法，只继承了QDialog类） 以下来源：https://www.cnblogs.com/rainbow70626/p/6919240.html 1234567891011121314#include &lt;QDialog&gt; #include \"ui_dialog.h\"class Dialog : public QDialog { Q_OBJECT public: Dialog(QWidget *parent = 0); ~Dialog();protected: void changeEvent(QEvent *e);private: Ui::Dialog *ui;private slots: void on_pushButton_clicked(); }; /home/xiaomu/QT/build-Application-Desktop-Debug/ui_qwdialog.h UI—go to slot *//定义bool型输出变量* ​ bool enable = false; ​ //调用文字属性设置变量,传输输入变量enable用于保存是否点击了ok按钮，第二个参数为文字属性对话框默认值 ​ QFont font = QFontDialog::getFont(&amp;enable,QFont(“宋体”,20,QFont::Bold),this,”自定义文字属性”); ​ //当点击属性对话框的ok按钮后，变量enable的值为true ​ if(enable) ​ { ​ ui-&gt;label-&gt;setFont(font); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// qApp-&gt;setFont(QFont(\"宋体\",20,QFont::Bold)); QFont font; //设置文字字体 font.setFamily(\"宋体\"); //设置文字大小为50像素 font.setPixelSize(50); //设置文字为粗体 font.setBold(true); //封装的setWeight函数 //设置文字为斜体 font.setItalic(true); //封装的setStyle函数 //设置文字大小 font.setPointSize(20); //设置文字倾斜 font.setStyle(QFont::StyleItalic); //设置文字粗细//enum Weight 存在5个值 font.setWeight(QFont::Light); //设置文字上划线 font.setOverline(true); //设置文字下划线 font.setUnderline(true); //设置文字中划线 font.setStrikeOut(true); //设置字间距% font.setLetterSpacing(QFont::PercentageSpacing,300); //300%,100为默认 //设置字间距像素值 font.setLetterSpacing(QFont::AbsoluteSpacing,20); //设置字间距为100像素 //设置首个字母大写（跟参数有关，也可以设置全部大写AllUppercase） font.setCapitalization(QFont::Capitalize); //通过QFontMetrics获取字体的值 QFontMetrics fm(font); qDebug() &lt;&lt; fm.height(); //获取文字高度 qDebug() &lt;&lt; fm.maxWidth(); //获取文字宽度 //通过QFontInfo获取也能获取字体信息 QFontInfo fInfo(font); qDebug() &lt;&lt; fInfo.family() &lt;&lt;\" \"&lt;&lt;fInfo.style() &lt;&lt; fInfo.pixelSize() &lt;&lt; fInfo.overline(); //设可以单独置QPlainTextEdit字体 //ui-&gt;plainTextEdit-&gt;setFont(font); //将当前设置的字体设置为默认字体 qApp-&gt;setFont(font); 非自动生成的，需要在cpp文件中手动添加链接关系 .h文件中声明函数 .cpp文件中设置功能，若非自动生成，则需要在cpp文件setup处手动添加连接关系，具体查看测试文件qwdialog 关联-QT信号与槽机制详解信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。 信号（Signal）就是在特定情况下被发射的事件，例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。 槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。 信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是： QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); connect() 是 QObject 类的一个静态函数，而 QObject 是所有 Qt 类的基类，在实际调用时可以忽略前面的限定符，所以可以直接写为： connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); 其中，sender 是发射信号的对象的名称，signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。 SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。例如，在 samp2_1（前面章节中的项目）的 ui_widget.h 文件中，在 setupUi() 函数中有如下的语句： QObject::connect(btnClose, SIGNAL(clicked()), Widget, SLOT(close())); 其作用就是将 btnClose 按钮的 clicked() 信号与窗体（Widget）的槽函数 close() 相关联，这样，当单击 btnClose 按钮（就是界面上的“Close”按钮）时，就会执行 Widget 的 close() 槽函数。 关于信号与槽的使用，有以下一些规则需要注意： 一个信号可以连接多个槽，例如： connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(addFun(int));connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(updateStatus(int)); 这是当一个对象 spinNum 的数值发生变化时，所在窗体有两个槽进行响应，一个 addFun()用于计算，一个 updateStatus() 用于更新状态。 当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次执行。 当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型，但可以不写参数名称。 多个信号可以连接同一个槽，例如在 samp2_2（前面章节中的项目）中，让三个选择颜色的 RadioButton的clicked() 信号关联到相同的一个自定义槽函数 setTextFontColor()。 connect(ui-&gt;rBtnBlue,SIGNAL(clicked()),this,SLOT(setTextFontColor()));connect(ui-&gt;rBtnRed,SIGNAL(clicked()),this,SLOT(setTextFontColor()));connect(ui-&gt;rBtnBlack,SIGNAL(clicked()),this,SLOT(setTextFontColor())); 这样，当任何一个 RadioButton 被单击时，都会执行 setTextFontColor() 函数。 一个信号可以连接另外一个信号，例如： connect(spinNum, SIGNAL(valueChanged(int)), this, SIGNAL (refreshInfo(int)); 这样，当一个信号发射时，也会发射另外一个信号，实现某些特殊的功能。 严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。 在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT。 当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。 信号与槽机制是 Qt GUI 编程的基础，使用信号与槽机制可以比较容易地将信号与响应代码关联起来。 QtDesiger 更改按钮的背景、字体颜色、大小1、简介更改QtDesgner 按钮上的背景、字体颜色、字体大小、字体格式 2、更改背景代码中： 12self.pushButton.setStyleSheet(\"border-image:url(./image/test.png)\")border-image:url(./image/test.png) 3、更改字体颜色、大小、格式1self.pushButton.setStyleSheet(\"color:rgb(0,0,255)\") font 修改 纯QT代码较复杂，暂时不考虑。qtcreator 使用快捷键 功能 快捷键 解释 Switch Header/Source F4 在同名的头文件和源程序文件之间切换 Follow Symbol Under Cursor F2 跟踪光标下的符号，若是变量，可跟踪到变量声明的地方；若是函数体或函数声明，可在两者之间切换 Switch Between Function Declaration and Definition Shift+F2 在函数的声明（函数原型）和定义（函数实现）之间切换 Refactor\\Rename Symbol Under Cursor Ctrl+Shift+R 对光标处的符号更改名称，这将替换到所有用到这个符号的地方 Refactor\\Add Definition in .cpp 为函数原型在 cpp 文件里生成函数体 Auto-indent Selection Ctrl+I 为选择的文字自动进行缩进 Toggle Comment Selection Ctrl+/ 为选择的文字进行注释符号的切换，即可以注释所选代码，或取消注释 Context Help F1 为光标所在的符号显示帮助文件的内容 Save All Ctrl+Shift+S 文件全部保存 Find/Replace Ctrl+F 调出查找/替换对话框 Find Next F3 查找下一个 Build Ctrl+B 编译当前项目 Start Debugging F5 开始调试 Step Over F10 调试状态下单步略过，即执行当前行程序语句 Step Into F11 调试状态下跟踪进入，即如果当前行里有函数，就跟踪进入函数体 Toggle Breakpoint F9 设置或取消当前行的断点设置 项目相关-数据显示QLabel 用于显示字符串，QLineEdit 用于显示和输入字符串。这两个类都有如下的两个函数用于读取和设置显示文字。 12QString text() constvoid setText(const QString &amp;) column row action添加图像节点 1234567891011121314151617181920212223242526272829303132void MainWindow::on_actAddFiles_triggered(){//添加图片文件节点 QStringList files=QFileDialog::getOpenFileNames(this,\"选择一个或多个文件\",\"\",\"Images(*.jpg)\");//多选文件 if (files.isEmpty()) //如果一个文件都没选 return; QTreeWidgetItem *parItem,*item; //节点 item=ui-&gt;treeFiles-&gt;currentItem(); //当前节点 if (item-&gt;type()==itImageItem) //若当前节点是图片节点，取其父节点作为父节点 parItem=item-&gt;parent(); else //否则取当前节点为父节点 parItem=item; for (int i = 0; i &lt; files.size(); ++i) { QString aFilename=files.at(i); //得到StringList里的一行，也就是一个文件名 addImageItem(parItem,aFilename); //添加一个图片节点 }}void MainWindow::addImageItem(QTreeWidgetItem *parItem, QString aFilename){//添加一个图片文件节点 QIcon icon(\":/images/icons/31.ico\");//ICON的图标 QString NodeText=getFinalFolderName(aFilename); //获得最后的文件名称 QTreeWidgetItem *item; //节点 item=new QTreeWidgetItem(MainWindow::itImageItem); //新建节点时设定类型为 itImageItem item-&gt;setIcon(colItem,icon); //设置图标 item-&gt;setText(colItem,NodeText); //最后的文件夹名称 //item-&gt;setText(colSecond,\"type=itImageItem; data=\"+aFilename); //完整目录名称 item-&gt;setText(colItemType,\"type=itImageItem\"); //完整目录名称 item-&gt;setFlags(Qt::ItemIsSelectable | Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsAutoTristate); //设置节点选项 item-&gt;setCheckState(colItem,Qt::Checked); //节点选中 item-&gt;setData(colItem,Qt::UserRole,QVariant(aFilename)); //设置节点Qt::UserRole的Data,存储完整文件名称 parItem-&gt;addChild(item); //在父节点下面添加子节点} QFileSystemModel 提供了一个可用于访问本机文件系统的数据模型。 文本文档读入数据并显示 多UI并列设计 QT MDI 应用四界面方案 —- usel删去 读写文件方式 7_1 采集项目中的图片 用 QFile 类的 IODevice 读写功能直接进行读写 io设备 利用 QFile 和 QTextStream 结合起来，用流（Stream)的方法进行文件读写。 读写相关 关于中文乱码 最后读取编码，并且发送一定位数的编码数据 QFile 负责文件的 IO 设备接口，即与文件的物理交互； QDataStream 以数据流的方式读取文件内容或写入文件内容。 dat文件读取与写入 以下qt例程 （用qt4写了一遍5-sample）熟悉显示功能、读取功能、截取视频流方式 1.mainwindow 窗口样式界面简单，省略 label Qlabel 2.application dialog样式 —-学习常用按键以及命名习惯 包含 修改字体、颜色 使用功能键位：（class）QPushButton QCheckBox 方框打勾 QRadioButton 圆圈打勾 QPlainTextEdit 命名习惯（暂时这样）：btn（OK、CLOSE、cancel） chkBox（Bold、Under、italic）、rBtn（Black、Blue、Red） txtEdit 3.纯代码编写界面 sample2.3，同2——了解原理、以后再学习 建立一个 Widget Appliation 项目 关键是取消创建窗体，即不勾选“Generate form”（创建界面）复选框，无选项框选 iniUI 声明函数—代码建立功能键位—建立功能映射—connect相关 声明class 自动生成，不要修改，注意变量 4.字符串读取模板 qt宏、顺序容器关联容器、迭代器、foreach关键字、库模块，嗨呀，没弄懂….以后再说各类附加模块 qt界面修改尺寸——geometry frame 框架修改#frame{border:1px solid rgb(0,255,0)} //frame代表你需要设置边框的frame对象名，1px是边框的线宽，solid为边框形式为实线，rgb为边框颜色 css border：solid实线，dashed虚线；dotted点状,,double双线border:0.5px solid rgb(25,25,25) border:2px dashed rgb(255,15,15) border:0px solid 关于Qstyle Stylesheet如果你对某个widget设置QStyle，那么该样式只对该widget有效，其子widget不受影响；但如果设置样式表，那么所有的子widget会继承该样式表。 利用sheet实现只修改外部不修改内部123456789101112131415161718QGroupBox { border-color: rgb(156, 156, 156); border-width: 1px; border-style: solid; margin-top: 0.5ex;} // 这里可以实现单部分修改QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; margin-left: 2px; padding: 0 0px;}QpushButton { border-color: rgb(255, 15, 15); border-width: 2px; border-style: dashed;} 图像化设置圆形一、使用setStyleSheet方法使用的主要是使用border-radius 属性，关于这个属性，可选的样式有border-top-left-radius 设置左上角圆角;border-top-right-radius 设置右上角圆角;border-bottom-left-radius 设置左下角圆角;border-bottom-right-radius 设置右下角圆角;border-radius 设置四个角圆角; 关于border-radius 后面的参数(1)一个参数 (2)两个参数border-radius: 15px 50px第一个参数设置X轴方向的半径第二个参数设置Y轴方向的半径 从图中可以看出设置一个参数代表X轴和Y轴设置了同样的值，而两个参数分别为X轴和Y轴方向的半径。大家可以根据不同需要去设置参数。 border:2px groove gray;border-radius:50px;padding:2px 4px solid pushbutton样式选择1234567891011121314151617181920212223242526QPushButton{border-radius:10px;border:2px solid white;border:2px solid white;color:white;background:transparent;}QPushButton:hover{border:2px solid rgb(71,186,204);color:rgb(71,186,204);background:transparent;}QPushButton:pressed{border:2px solid white;color:white;background-color:rgb(71,186,204);}QPushButton:!enabled{border:2px solid rgb(130,130,130);color:rgb(130,130,130);}QPushButton:focus {border:2px solid black;color:black;background-color:white; pushbutton与toolbutton tool工具栏按钮 push 普通按钮 comm.h √ comm.cpp √ 设置参数值不用管，使能 重置 停止 运行 难顶，浪费了一天时间控制模型不改了，就用楼下的电脑修改就好 其余控制通过5.8进行，我可太笨了 关于ads通信，发送图片","categories":[],"tags":[]},{"title":"latex_note","slug":"latex-note/latex-note","date":"2020-12-09T10:21:08.000Z","updated":"2020-12-09T10:51:30.093Z","comments":true,"path":"2020/12/09/latex-note/latex-note/","permalink":"http://xiaomuhou.github.io/2020/12/09/latex-note/latex-note/","excerpt":"LaTex常用符号，备份一下，便于查询","text":"LaTex常用符号，备份一下，便于查询 1、希腊字母 名称 大写 code 小写 code alpha A A α \\alpha beta B B β \\beta gamma Γ \\Gamma γ \\gamma delta Δ \\Delta δ \\delta epsilon E E ϵ \\epsilon zeta Z Z ζ \\zeta eta H H η \\eta theta Θ \\Theta θ \\theta iota I I ι \\iota kappa K K κ \\kappa lambda Λ \\Lambda λ \\lambda mu M M μ \\mu nu N N ν \\nu xi Ξ \\Xi ξ \\xi omicron O O ο \\omicron pi Π \\Pi π \\pi rho P P ρ \\rho sigma Σ \\Sigma σ \\sigma tau T T τ \\tau upsilon Υ υ \\upsilon phi Φ \\Phi ϕ \\phi chi X X χ \\chi psi Ψ \\Psi ψ \\psi omega Ω \\Omega ω \\omega 2、上标、下标、求和、括号 上标 x^2、 x^y 、e^3 下标 x_0、a_1、T_1 求和 \\sum ∑ 求和上下标 \\sum_0^3 、\\sum_0^{\\infty} 、\\sum_{-\\infty}^{\\infty} 0-3,0-∞，-∞-+∞ 中括号 [s(s+1)-(s-1)(s-2)] [ s ( s + 1 ) − ( s − 1 ) ( s − 2 ) ] 花括号 \\lbrace x-y \\rbrace { x − y } 3、三角函数、指数、对数 sin \\sin(x) sin ⁡ ( x ) cos \\cos(x) cos ⁡ ( x ) tan \\tan(x) t a n ( x ) log \\log_2 10 log ⁡ 2 10 ln \\ln2 ln ⁡ 2 4、运算符 乘 \\times × 除 \\div ÷ 加减 \\pm ± 减加 \\mp ∓ 求和 \\sum ∑ 求积 \\prod ∏ 微分 \\partial ∂ 积分 \\int 、\\displaystyle\\int ∫ 、∫ 不等于 \\neq ≠ 大于等于 \\geq ≥ 小于等于 \\leq ≤ 约等于 \\approx ≈ 不大于等于 x+y \\ngeq z x + y ≱ z 点乘 a \\cdot b a ⋅ b 星乘 a \\ast b a ∗ b 分式 \\frac{b}{a}、\\frac{x}{y}、\\frac{1}{x+1} 5、数学符号 无穷 \\infty ∞ 矢量 \\vec{a} a ⃗ 一阶导数 \\dot{x} x ˙ 二阶导数 \\ddot{x} x ¨ 算数平均值 \\bar{a} a ˉ 概率分布 \\hat{a} a ^ 虚数i ii、j jj \\imath、\\jmath ı 、ȷ 四种省略号 \\ldots；\\cdots；\\vdots；\\ddots … ； ⋯ ；⋮ ； ⋱ 6、高级运算符 平均数运算 \\overline{xyz} x y z ‾ 开二次方运算 \\sqrt x \\ 开方运算 \\sqrt[开方数]{被开方数} x + y 3 极限运算一 \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}} lim ⁡ y → 0 x → ∞ x y \\ 极限运算二 \\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}} lim ⁡ y → 0 x → ∞ x y 求和运算一 \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}} ∑ y → 0 x → ∞ x y 求和运算二 \\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}} ∑ y → 0 x → ∞ x y \\ 积分运算一 \\int^{\\infty}_{0}{xdx} ∫ 0 ∞ x d x 积分运算二 \\displaystyle \\int^{\\infty}_{0}{xdx} ∫ 0 ∞ x d x 微分运算 \\frac{\\partial x}{\\partial y}、\\frac{\\partial^2x}{\\partial y^2} ∂y∂x、∂ 2 x ∂ y 2 7、集合运算 属于 x\\iny x ∈ y 不属于 \\notin x ∉ y 子集 x \\subset y、x \\supset y x ⊂ y ⊂y、x ⊃ y x 真子集 \\subseteq、\\supseteq x ⊆ y x 、 x ⊇ y x 并集 \\cup x ∪ y x 交集 \\cap x ∩ y x 差集 \\setminus x ∖ y x 同或 \\bigodot x ⨀ y x 同与 \\bigotimes x ⨂ y x 异或 \\bigoplus a ⨁ b a 实数集合 \\mathbb{R} R \\mathbb{R}R 自然数集合 \\mathbb{Z} Z 8、括号字体 字体变大 \\displaystyle x + y y + z 下划线 \\underline x + y ‾ \\underline{x+y} 上大括号 \\overbrace{式子} a + b + c + d ⏞ 2.0 下大括号 \\underbrace{式子} a + b + c ⎵ 1.0 + d a+\\underbrace{b+c}_{1.0}+d 上位符号 \\stacrel{上位符号}{基位符号} x ⃗ = d e f x 1 , … , x n","categories":[],"tags":[]},{"title":"爬虫记录_bro","slug":"爬虫记录-bro/爬虫记录-bro","date":"2020-12-05T07:38:46.000Z","updated":"2021-01-05T13:55:25.315Z","comments":true,"path":"2020/12/05/爬虫记录-bro/爬虫记录-bro/","permalink":"http://xiaomuhou.github.io/2020/12/05/%E7%88%AC%E8%99%AB%E8%AE%B0%E5%BD%95-bro/%E7%88%AC%E8%99%AB%E8%AE%B0%E5%BD%95-bro/","excerpt":"爬虫记录出于兴趣跟着一个本科的老学长学学这个方向，顺便做个记录，方便查看 （超级超级基础） 持续更新…","text":"爬虫记录出于兴趣跟着一个本科的老学长学学这个方向，顺便做个记录，方便查看 （超级超级基础） 持续更新… 一些脚本 油猴插件:https://www.tampermonkey.net/脚本:https://greasyfork.org/zh-CN 插件入门级别爬虫-webscraper 单页抓取例子选择抓取的对象相关打开目标页面-webscraper-create new sitemap—设置相关参数 抓取开始-根据参数进行填写 select选取目标-dowload-运行（记得勾选multiple） 启动设置的脚本过程启动-sitemapdouban-scrape-设置时间（根据网速） 导出过程sitemap-export excel文件操作 cav 过程总结1.打开webscraper 2.创建sitemap 3.设置selector（根据爬去类型进行分析计算） 4.启动程序并保存数据 例子测试，爬一下我自己的博客内容文件—测试成功 代码—编写脚本文件 下一部分是网页开发知识相关—css与html(明晚更新) （小事情—【】+（）) css html相关html 超文本标记语言 css javascript css-设置各种字体大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;first(runoob.com)&lt;/title&gt;&lt;style&gt;body{ background-color:#d0e4fe;}h1{ color:orange; text-align:center;}p{ font-family:\"Times New Roman\"; font-size:20px;}h4{ background-color:red; text-align:center;}a{ color: red}h4 b{ color: blue}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;简单测试一下!&lt;/h1&gt;&lt;p&gt;这是WM的个人博客。&lt;a href=\"www.xiaomuh.cn\"&gt;小牧网站&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;笔记相关&lt;b href=\"www.google.cn/\"&gt;搜索学习&lt;/b&gt;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; elements- 选择多列信息常规方式-第二类爬取不勾选mutiply sitemap_new 选择元素的原因是，提供一个较为精确的基准，方便多列爬取而不发生错误排列。 elements 元素选择器 —li class 选择按钮—之后在下方查看各个参数信息 整体—格式改变—选择elements—multiply 进入从分支选择-txt格式文件 对齐—第一个选择作为基准-其余不勾选multiply可以自动对齐 尝试爬取论文 graph查看节点分布 翻页功能根据翻页链接比较区别 url链接页数格式修改 页数[1-n],可进行选择页数遍历(尝试抓取liu博的机器人文章内容)如下 对于？后面的条件参数可以忽略(测试一下) 文件-zhuhuyys.csv完成 TH—缺乏隔多页处理方法，简介只能表面列表，针对不规则链接如何进行分析应用 等差翻页方式比如豆瓣差值页数差值为25 [0-225:25] 关于常见网站翻页方式 翻页 滚动形式网页怎么抓取1.制作 Sitemap刚开始我们要先创建一个 container，包含要抓取的三类数据，为了实现滚动到底加载数据的功能，我们把 container 的 Type 选为 Element scroll down，就是滚动到网页底部加载数据的意思。 元素名后加个 nth-of-type(-n+100)，暂时只抓取前 100 条数据。注意加： 以上是重点 然后我们保存 container 这个节点，并在这个节点下选择要抓取的三个数据类型。 首先是标题，我们取名为 title，选择的元素名为 [itemprop='zhihu:question'] a： 然后是答题人名字 name 与 赞同数 like，选择的元素名分别为 #Popover10-toggle a 和 button.VoteButton--up： 尝试爬取readhub滚动网页相关内容 p父话题 由单体选择不要总体选了再父话题，容易出错。无法选择到单个框位置，就先选标题再通过p选框，在选择整体。 完成 翻页 滚动型混合界面滚动型页面收集方式基本类似， sitemap-type 微博混合型抓取马前卒新闻页面尝试 翻页寻找规律 马微博是混合型 https://weibo.com/u/6534413254 https://weibo.com/u/6534413254?is_search=0&amp;visible=0&amp;is_all=1&amp;is_tag=0&amp;profile_ftype=1&amp;page=2#feedtop https://weibo.com/u/6534413254?is_search=0&amp;visible=0&amp;is_all=1&amp;is_tag=0&amp;profile_ftype=1&amp;page=3#feedtop 可以发现规律 需要限定数量就选择 nth-of-type(-n+100) 修改界面 edit metadata 修改爬取到页数 作业：没有规律网页如何翻页爬取 提示：element click 点击爬取 点击爬取-无规则翻页element click click selector 选择 css selector 选择多个项目，完成 思考：这个可以应用于所有翻页型网页，无论有没有规则。 作为书签 选择link类型 测试—知乎yys emmm 文章太少嘞，换个师兄，知名劝退师兄2333 内容太多了 思考：如何爬取详细信息—-界面信息内容较少，无法获得有效信息 解决方式 下一节 爬取子页面具体信息sitemap 子内容选择link，点击目标链接 切换目标页面，重新在同一项目中操作，选择内容进行操作 测试 YYS文章，尝试加入翻页功能 测试完成 保存于硬盘 爬取图片文件目标网页 类型选择图片image 点击链接可以显示图片 一些法律小知识数据不可商业化活动 UTS相关规定 robots.txt 软件爬虫告一段落，目前为止，较为简单，算是学学新东西，下一阶段顺便复习一下语法基础。","categories":[],"tags":[]},{"title":"configure_bag","slug":"configure-bag/configure-bag","date":"2020-11-30T10:25:52.000Z","updated":"2020-11-30T10:54:01.700Z","comments":true,"path":"2020/11/30/configure-bag/configure-bag/","permalink":"http://xiaomuhou.github.io/2020/11/30/configure-bag/configure-bag/","excerpt":"摄像头调参二三包含补充QT上位机编写、ip配置的一点疑问（后续解决后会补充）、 以及补充后续图像处理相关项目内容","text":"摄像头调参二三包含补充QT上位机编写、ip配置的一点疑问（后续解决后会补充）、 以及补充后续图像处理相关项目内容 摄像头通过IP配置实现连接是一种比较常见的方式，但是实际过程中发现并不是随便设置IP，并将摄像头配置成对应静态ip就能实现通信。 比如今天下午选用网卡设置了多组IP，有的无法检测信息，有的检测到了但是无法识别图像传输界面，最后选择了一组跟本机其余无线网卡类似的一组ip，即前六位一致，目前为止，通信效果良好。推测是每个电脑IP设置具有一定规则，不能随便去设置，至少保证前六位一致。 （原因后续深入了解了之后继续补充） 1.基于TCP/IP通信协议，IP设置与传感器本身并无关系，设置一个符合本机电脑规则的IP地址，再据此自动设置或者将传感器设置为静态地址，手动调节，一般就可以实现通信。 2.关于Linux 中的反向过滤技术处理，将默认数值设置为0即可，具体程序如下 在确定相机连接正常的情况下,可通过以下命令查看反向过滤功能是否开启: 1sysctl -a 2&gt;/dev/null | grep '\\.rp_filter' 根据网卡类别，将摄像机使用的网卡参数值设置为0.，相关操作如下 12sudo sysctl net.ipv4.conf.all.rp_filter=0sudo sysctl net.ipv4.conf.占用网卡名字.rp_filter=0 目前为止，几张网卡就能同时处理几个传感器，为了降低硬件使用率，可以通过工业路由器将传感器信息集成之后，进行统一处理 （有个问题在于，无线通信是否可靠？ 5G、6G路由器的核心技术又是什么，帮忙干活的时候跟工程师仔细去了解一下）—-（关于一个应用拓展 基于DSP的二代通信技术，之后深入了解了会做一次记录，挖个坑～） QT上位机这里两周内会补充有关火星车图像处理上位机编写的架构和底层代码分析记录 （C艹记录相关）准备跟py放那篇放一起啦 图像处理针对高帧率视频图像进行实时分析相关内容，以后会记录一下老师的项目，学习为主。","categories":[{"name":"camera","slug":"camera","permalink":"http://xiaomuhou.github.io/categories/camera/"}],"tags":[]},{"title":"lifespan","slug":"lifespan/lifespan","date":"2020-11-07T12:48:59.000Z","updated":"2020-11-07T13:36:16.341Z","comments":true,"path":"2020/11/07/lifespan/lifespan/","permalink":"http://xiaomuhou.github.io/2020/11/07/lifespan/lifespan/","excerpt":"无常的人生-小记今天心情还挺复杂的，不自主的想着好多事情，不想让熟人知道，但是又想倾诉一下，所以在博客里稍微说一说，（未来不管陌生人还是熟人，或者是自己，看到这篇小记，是否会心有所感呢？）","text":"无常的人生-小记今天心情还挺复杂的，不自主的想着好多事情，不想让熟人知道，但是又想倾诉一下，所以在博客里稍微说一说，（未来不管陌生人还是熟人，或者是自己，看到这篇小记，是否会心有所感呢？） 1.纪念一场似是而非的“感情”友谊和爱情终究是有差别的，这是我所笃定的，但是差别的界定，我好像又是模糊的，前些天我好像做了一些很对不起你的事情，但是我又不得不这么做。 为什么我下不了决心呢，我后来自己想了想，其实不是我所谓的不懂体贴、太过“直男”，而是我觉得我们太熟悉了，虽然几乎有两年没见过，熟悉带来的于我而言就是陌生，更重要的一点是，你我都不知道这段未来的感情里掺杂了多少另外多余的东西，比如周围的环境、别人的看法，各自的兴趣爱好甚至与一些观念理想，你我都不是好多年前的那个人了。 说实话，很久之前，我应该是喜欢的，不过那会不敢跟你说，也不知道你怎么想，再后来，经历了很多事情，我的想法也慢慢变了，但是终究你对我而言，和别人是不同的，这可能就是你说的差别对待感觉的来源，但是这个差别来自于很多年前，并且可能并不会更进一步，我害怕我以后会伤害你，所以我在不算开始的现在退出，我也不想去试这个模糊感是不是有未来，我总感觉有些事情应该是顺其自然的… 希望你未来能找到更合适的，我会衷心的祝福，真的 我们应该还是朋友吧…有些事不说还好，说了真是尴尬 确定不了你的想法为什么忽然那么坚定，我也无法确定我的想法，总体来讲，就是这个原因。 我会努力提高自己，当然希望你也能健健康康的快乐生活，我会帮助你，以一个好朋友的身份，不管你接不接受。没有前一段经历，或许我也不能下定决心做一件事。 感觉你最近蛮开心的，那我也就放心了，希望我没有对你造成什么伤害… 你可能不会看到这篇碎碎念的文章吧，毕竟我没和别人讲过这个博客，我居然能写出这么多废话… 想起来又是好复杂，感觉好烦，爱情真是烦人啊，不如多看两篇文献… 2人生之路漫漫长未来几年的方向应该是确定了，模糊又坚定，我有自己的指标，我会努力去完成 踏实一点、坚定一点、乐观一点 3现在是不是很奇怪的顺序，确实，不过这本身就是一篇奇怪的文章，和我的现实性格一点也不搭。 现在我做的应该也是踏踏实实的，把每日目标和小目标努力完成了，最近遇到点小难题，一点一点得去记录并且克服掉 摸鱼虽然舒服，但是真的浪费时间，拒绝正式时间摸鱼，从我做起 严格规划时间了呀啊喂！ 周末晚之前做一版，下周严格的把模型推导完，整理知识，克服难题 人生啊—-真是漫长 应该不会有人看到吧，真是尴尬…","categories":[],"tags":[]},{"title":"reading_note1","slug":"reading-note1/reading-note1","date":"2020-11-02T12:29:28.000Z","updated":"2020-11-30T11:00:19.086Z","comments":true,"path":"2020/11/02/reading-note1/reading-note1/","permalink":"http://xiaomuhou.github.io/2020/11/02/reading-note1/reading-note1/","excerpt":"并联机构优化阅读笔记1A new method for optimum design of parallel manipulator based on kinematics and dynamics 并联机械臂优化设计 （不太规范，慢慢进步）（推导及公式说明latex 写完后会补充）","text":"并联机构优化阅读笔记1A new method for optimum design of parallel manipulator based on kinematics and dynamics 并联机械臂优化设计 （不太规范，慢慢进步）（推导及公式说明latex 写完后会补充） 综合考虑机构运动学与动力学特性，一种优化机构尺寸参数的方案，可以用于提高并联机器人动态性能 Abstract This paper presents a new method for the optimum design of parallel manipulators by taking both the kinematics and dynamic characteristics into account. The optimum design of a 3-DOF 4-RRR planar parallel manipulator with actuation redundancy is investigated to demonstrate the method. The kinematic performance indices such as the conditioning index, the velocity index, and workspace area are analyzed.Further, the dynamic dexterity, which is used to evaluate the dynamic characteristics, is investigated. The corresponding atlases are represented graphically in the established design space. Based on these atlases, the geometrical parameters without dimension are determined. Then the optimum dimension parameters are achieved based on the optimum non-dimensional result. By using the method proposed in this paper, the designer can obtain the optimum result with respect to both kinematic performance indices and dynamic performance indices. Since the dynamic performance is considered in the process of optimum design by using the method proposed in this paper, it is expected to realize the high dynamics of parallel manipulators. Introduction Parallel manipulators have attracted much attention in both industry and academia because of their conceptual potentials in high motion dynamics and accuracy combined with high structural rigidity due to their closed kinematic loops. However, there is a gap between the expectation and practical application of parallel manipulators in the machine tool/robot sectors [1, 2]. One of the reasons is that their potentially desirable high dynamics can not be realized since the dynamic characteristics are not considered in the optimal design phase and only are considered in the modelbased control after the prototype is built. Since the prototype is fabricated, the improvement of dynamic characteristics is limited even if model-based control is used. If the dynamic characteristics can also be involved in the process of the optimum design before the prototype is built, the dynamic performance will be improved. Thus, it is helpful to realize the high motion dynamics. 并联机构实际应用动态效果一般，原因在于优化设计阶段未考虑动态特性，模型完成后，控制就会受限于模型本身，动态特性无法实现，如果在优化设计时考虑到动态特性，整体效果会得到改善。 Optimal kinematic design is an important subject in designing a parallel manipulator. No matter how simple the parallel manipulator is, the optimum design is always challenging. Many efforts have been contributed to this issue [3–7]. These approaches can be classified into two kinds: one is based on the performance indices and the other is based on the performance atlases. The methods based on the performance indices are traditional ones, implemented in the commercial software MATLAB based on an established object function. If the design criterion number is increased, the procedure will be more complicated. The method based on the performance atlases can give designers a global and visual information on with what kind of link lengths the mechanism can have a good or best performance. However, the dynamic performance is usually neglected. 最优设计局限性，未考虑动态特性 Some researchers attempt to study the dynamic performance by defining some dynamic performance indices. Conventionally, dynamic manipulability ellipsoid (DME) [8, 9] and generalized inertia ellipsoid (GIE) [10] were used as performance indices to evaluate the dynamic manipulability of a robot manipulator.Besides, some other measures for evaluating dynamic manipulability have been proposed. Graettinger and Krogh [11] introduced acceleration radius. Hashimoto [12] used the harmonic mean of the square singular values matrix to evaluate the dynamic manipulability.Li et al. [13] presented the smallest singular value of inertia matrix of a manipulator as the evaluation index when the manipulability in the hardest direction was considered. However, almost all of these contributions concentrated on the analysis and evaluation of the dynamic characteristics, and are not used for the optimum design to improve the dynamic performance.Although Asada [14] draw the GIE on a computer display and aid the design by visualizing the dynamic behavior, it is difficult to obtain an optimum design result. 关于动态性能指标集中指标，注意一下文中提到的文献13中惯性矩阵最小奇异值优化方式，简单优化方式 动态指标优化方式与问题 The goal of this paper is to present a new method to take the dynamic characteristics of parallel manipulators into account in the process of optimum design.Based on the performance atlases, both the kinematics and dynamics of a 3-DOF 4-RRR planar parallel manipulator with actuation redundancy are involved.The kinematic performance indices such as the conditioning index, the velocity index, and workspace area are analyzed. Further, the dynamic dexterity of the manipulator is investigated. The corresponding atlases are represented graphically in the established design space. Based on these atlases, the geometrical parameters without dimension are determined. Then the optimum dimensional parameters are achieved based on the optimum nondimensional result. By using the method proposed in this paper, the designer can obtain the optimum result with respect to both kinematic performance indices and dynamic performance indices. 目标：基于performance atlase 性能图谱优化分析 运动学分析Inverse kinematics 常规闭链解法，不记录了，大同小异 Velcocity equation 求解jacobian 这里方法类似于向量推导，从表达过程看，与通过那篇向量几何范数方式推导的硕士论文（郭-）结果一致，之前看那篇方法没有引用相关文献，可能方法出自这里…… 运动学性能指标及图谱推导补充（latex写好会放过来） 全局性能指标与图谱The condition number is regarded as the local performance index for evaluating the velocity, accuracy, and rigidity mapping characteristics between the joint variables and the moving platform. The condition number κ is defined as 1 ≤ κ = σ 2 ≤∞ σ 1 where σ 1 and σ 2 are the minimum and maximum singular values of the Jacobian matrix associated with a given posture.条件数可用于评估关节变量、平台速度、精度、刚度局部性能指标。 全局速度指标与图谱输出速度作为并联机械臂的重要指标，速度性能越好，最小速度越大。 动力学推导（虚功原理）常规推导方式，不作记录 基于图谱的优化设计 通过线性规划，给出了一个可行区域 这里注意数学理论上最优与工程最优区别，实际工程上需要从实际出发，在可行域内选择合适尺寸参数。 基于运动学优化设计 工作空间、调节指数以及输出速度 基于运动学与动力学的优化设计 优化过程： 1.根据运动学性能指标划定规划域 2.根据动态性能指标确定另一个最佳区域，该区域为1子集 3.确定机械臂参数 4.基于逆运动学模型确定系统输入角度范围 5.确定系统机构质量 In order to investigate the performance of the designed manipulator, the condition number of Jacobian matrix and the distribution of κ D are given, as shown in Figs. 9 and 10. One may see that the condition number distribution and the distribution of κ D are symmetrical and the mechanism has the desired condition performance with η &gt; 0.11 and dynamic manipulability with η̄ D &gt; 0.05. In the center, the condition number of Jacobian matrix has the maximum value 0.33, and κ D = 0.12. It means that the 4-RRR manipulator has a better kinematic dexterity and dynamic manipulability in the center. 中心位置雅克比矩阵考虑 结论本文是一种综合考虑运动学与动态性能的优化方案，通过无量纲参数获取杆件尺寸。 目标操作器具备理想的运动学和动态性能。 （推导分析后续补充）","categories":[],"tags":[]},{"title":"numpy_py","slug":"numpy-py/numpy-py","date":"2020-10-29T11:32:35.000Z","updated":"2020-11-05T13:38:11.617Z","comments":true,"path":"2020/10/29/numpy-py/numpy-py/","permalink":"http://xiaomuhou.github.io/2020/10/29/numpy-py/numpy-py/","excerpt":"矩阵学习记录-数据分析方向后续扩展内容","text":"矩阵学习记录-数据分析方向后续扩展内容 学习资料来源—https://github.com/fengdu78/Data-Science-Notes 列表-矩阵 123import numpy as nparray = np.array([1,3,5],[4,6,9])prtint(array) 维度 1prtint(‘number of dim:',array.ndim) 行数与列数 1print('shape:',array.shape) 元素个数 1print('size:',array.size) 创建数组 1234567891011121314151617181920212223242526272829303132#一维import numy as npa=np.array([2,3,5],dtype=np.int32) #np.int默认int32print(a)print(a.dtype)#多维a=np.array([[1,2,3],[4,5,6]])print(a)#全0数组a=np.zeros((3,4))#注意括号#连续数组a=np.arange(0,20,2)print(a)0 2 ... 18#reshape改变形状b=a.reshape((2,3))#创建连续性数据a = np.linspace(1,10,20) # 开始端1，结束端10，且分割成20个数据，生成线段print(a)结果示例[ 1. 1.47368421 1.94736842 2.42105263 2.89473684 3.36842105 3.84210526 4.31578947 4.78947368 5.26315789 5.73684211 6.21052632 6.68421053 7.15789474 7.63157895 8.10526316 8.57894737 9.05263158 9.52631579 10. ]矩阵运算 Numpy 12345678910111213141516171819202122232425262728293031import numpy as np# 一维矩阵运算a = np.array([10,20,30,40])b = np.arange(4)print(a,b)[10,20,30,40] [0,1,2,3]c=a-bc=a*b #对位相乘c=b**2#数学工具c=np.sin(a)#数组对比，每一位都会输出真值#多维矩阵a = np.array([[1,1],[0,1]])b = np.arange(4).reshape((2,2))print(a)[[1 1] [0 1]]print(b)[[0 1] [2 3]]c = a.dot(b)#矩阵乘法print(c)[[2 4] [2 3]]# 多维矩阵乘法不能直接使用'*'号a = np.random.random((2,4))print(np.sum(a))print(np.min(a))print(np.max(a)) 12345678910111213141516171819print(\"a=\",a)a= [[0.48634962 0.74204282 0.09623356 0.69074812] [0.60218881 0.52734181 0.41434585 0.26626662]]如果你需要对行或者列进行查找运算，就需要在上述代码中为 axis 进行赋值。当axis的值为0的时候，将会以列作为查找单元，当axis的值为1的时候，将会以行作为查找单元。print(\"sum=\",np.sum(a,axis=1))sum= [2.01537412 1.8101431 ]print(\"min=\",np.min(a,axis=0))min= [0.48634962 0.52734181 0.09623356 0.26626662]print(\"max=\",np.max(a,axis=1))max= [0.74204282 0.60218881] 计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npA = np.arange(2,14).reshape((3,4))print(A)[[ 2 3 4 5] [ 6 7 8 9] [10 11 12 13]]# 最小元素索引print(np.argmin(A)) # 00# 最大元素索引print(np.argmax(A)) # 1111# 求整个矩阵的均值print(np.mean(A)) # 7.57.5print(np.average(A)) # 7.57.5print(A.mean()) # 7.57.5# 中位数print(np.median(A)) # 7.57.5# 累加print(np.cumsum(A))[ 2 5 9 14 20 27 35 44 54 65 77 90]# 累差运算B = np.array([[3,5,9], [4,8,10]])print(np.diff(B))[[2 4] [4 2]]？？？？？C = np.array([[0,5,9], [4,0,10]])print(np.nonzero(B))print(np.nonzero(C))(array([0, 0, 0, 1, 1, 1], dtype=int64), array([0, 1, 2, 0, 1, 2], dtype=int64))(array([0, 0, 1, 1], dtype=int64), array([1, 2, 0, 2], dtype=int64))# 仿照列表排序A = np.arange(14,2,-1).reshape((3,4)) # -1表示反向递减一个步长print(A)[[14 13 12 11] [10 9 8 7] [ 6 5 4 3]] 1234print(np.sort(A))[[11 12 13 14] [ 7 8 9 10] [ 3 4 5 6]] 1234567891011121314151617181920212223242526272829# 矩阵转置print(np.transpose(A))[[14 10 6] [13 9 5] [12 8 4] [11 7 3]]print(A.T)[[14 10 6] [13 9 5] [12 8 4] [11 7 3]]print(A)[[14 13 12 11] [10 9 8 7] [ 6 5 4 3]]print(np.clip(A,5,9))[[9 9 9 9] [9 9 8 7] [6 5 5 5]]clip(Array,Array_min,Array_max)将Array_min&lt;X&lt;Array_max X表示矩阵A中的数，如果满足上述关系，则原数不变。否则，如果X&lt;Array_min，则将矩阵中X变为Array_min;如果X&gt;Array_max，则将矩阵中X变为Array_max. 索引与切片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import numpy as npA = np.arange(3,15)print(A)[ 3 4 5 6 7 8 9 10 11 12 13 14]print(A[3])6B = A.reshape(3,4)print(B)[[ 3 4 5 6] [ 7 8 9 10] [11 12 13 14]]print(B[2])[11 12 13 14]print(B[0][2])5print(B[0,2])5# list切片操作print(B[1,1:3]) # [8 9] 1:3表示1-2不包含3[8 9]for row in B: print(row)[3 4 5 6][ 7 8 9 10][11 12 13 14]# 如果要打印列，则进行转置即可for column in B.T: print(column)[ 3 7 11][ 4 8 12][ 5 9 13][ 6 10 14]# 多维转一维A = np.arange(3,15).reshape((3,4))# print(A)print(A.flatten())# flat是一个迭代器，本身是一个object属性[ 3 4 5 6 7 8 9 10 11 12 13 14]for item in A.flat: print(item)34567891011121314 数组合并 123456789101112131415161718192021222324252627282930313233import numpy as npA = np.array([1,1,1])B = np.array([2,2,2])print(np.vstack((A,B)))# vertical stack 上下合并,对括号的两个整体操作。[[1 1 1] [2 2 2]]C = np.vstack((A,B))print(C)[[1 1 1] [2 2 2]]print(A.shape,B.shape,C.shape)# 从shape中看出A,B均为拥有3项的数组(数列)(3,) (3,) (2, 3)# horizontal stack左右合并D = np.hstack((A,B))print(D)[1 1 1 2 2 2]print(A.shape,B.shape,D.shape)# (3,) (3,) (6,)# 对于A,B这种，为数组或数列，无法进行转置，需要借助其他函数进行转置(3,) (3,) (6,)数组-矩阵print(A[np.newaxis,:]) # [1 1 1]变为[[1 1 1]][[1 1 1]]print(A[np.newaxis,:].shape) # (3,)变为(1, 3)(1, 3)print(A[:,np.newaxis])[[1] [1] [1]] 矩阵合并 12345# concatenate的第一个例子print(\"------------\")print(A[:,np.newaxis].shape) # (3,1)------------(3, 1) 12345678910111213141516171819202122232425262728293031323334A = A[:,np.newaxis] # 数组转为矩阵B = B[:,np.newaxis] # 数组转为矩阵print(A)[[1] [1] [1]]In [70]:print(B)[[2] [2] [2]]# axis=0纵向合并C = np.concatenate((A,B,B,A),axis=0)print(C)[[1] [1] [1] [2] [2] [2] [2] [2] [2] [1] [1] [1]]# axis=1横向合并C = np.concatenate((A,B),axis=1)print(C)[[1 2] [1 2] [1 2]] 12345678910111213141516171819202122232425262728# concatenate的第二个例子print(\"-------------\")a = np.arange(8).reshape(2,4)b = np.arange(8).reshape(2,4)print(a)print(b)print(\"-------------\")-------------[[0 1 2 3] [4 5 6 7]][[0 1 2 3] [4 5 6 7]]# axis=0多个矩阵纵向合并c = np.concatenate((a,b),axis=0)print(c)[[0 1 2 3] [4 5 6 7] [0 1 2 3] [4 5 6 7]]# axis=1多个矩阵横向合并c = np.concatenate((a,b),axis=1)print(c)[[0 1 2 3 0 1 2 3] [4 5 6 7 4 5 6 7]] 矩阵分割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import numpy as npA = np.arange(12).reshape((3,4))print(A)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]# 等量分割# 纵向分割同横向合并的axisprint(np.split(A, 2, axis=1))[array([[0, 1], [4, 5], [8, 9]]), array([[ 2, 3], [ 6, 7], [10, 11]])]# 横向分割同纵向合并的axisprint(np.split(A,3,axis=0))[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])]print(np.array_split(A,3,axis=1))[array([[0, 1], [4, 5], [8, 9]]), array([[ 2], [ 6], [10]]), array([[ 3], [ 7], [11]])]Numpy与相关参数import numpy as np# `=`赋值方式会带有关联性a = np.arange(4)print(a) # [0 1 2 3][0 1 2 3]b = ac = ad = ba[0] = 11print(a) # [11 1 2 3][11 1 2 3]print(b) # [11 1 2 3][11 1 2 3]print(c) # [11 1 2 3][11 1 2 3]print(d) # [11 1 2 3][11 1 2 3] copy()赋值方式没有关联性a = np.arange(4)print(a) # [0 1 2 3][0 1 2 3]b =a.copy() # deep copyprint(b) # [0 1 2 3][0 1 2 3]a[3] = 44print(a) # [ 0 1 2 44]print(b) # [0 1 2 3]# 此时a与b已经没有关联[ 0 1 2 44][0 1 2 3] 关于广播机制 numpy数组间的基础运算是一对一，也就是a.shape==b.shape，但是当两者不一样的时候，就会自动触发广播机制，如下例子 1234567891011rom numpy import arraya = array([[ 0, 0, 0], [10,10,10], [20,20,20], [30,30,30]])b = array([0,1,2])print(a+b)[[ 0 1 2] [10 11 12] [20 21 22] [30 31 32]] 当两个数组的trailing dimensions compatible时才会触发广播，否则报错ValueError: frames are not aligned exception。 上面表达意思是尾部维度必须兼容！ 常用函数12345x = np.array([1, 2, 3, 3, 0, 1, 4])np.bincount(x)array([1, 2, 1, 2, 1], dtype=int64)统计索引出现次数：索引0出现1次，1出现2次，2出现1次，3出现2次，4出现1次 1np.bincount(x,weights=w) Out[100]: 1array([ 0.1, -0.6, 0.5, 1.3, 1. ]) 怎么计算的？ 先对x与w抽取出来： 1x ---&gt; [1, 2, 3, 3, 0, 1, 4] w ---&gt; [0.3,0.5,0.7,0.6,0.1,-0.9,1] 索引 0 出现在x中index=4位置，那么在w中访问index=4的位置即可，w[4]=0.1 索引 1 出现在x中index=0与index=5位置，那么在w中访问index=0与index=5的位置即可，然后将两这个加和，计算得：w[0]+w[5]=-0.6 其余的按照上面的方法即可！ bincount的另外一个参数为minlength，这个参数简单，可以这么理解，当所给的bin数量多于实际从x中得到的bin数量后，后面没有访问到的设置为0即可。 1np.bincount(x,weights=w,minlength=7) 1array([ 0.1, -0.6, 0.5, 1.3, 1. , 0. , 0. ]) 与上面相比多了两个0，这两个怎么会多？ 上面知道，这个bin数量为5，index从0到4，那么当minlength为7的时候，也就是总长为7，index从0到6，多了后面两位，直接补位为0即可！ np.argmax()函数原型为：numpy.argmax(a, axis=None, out=None). 函数表示返回沿轴axis最大值的索引。 12345678910111213141516171819202122232425x = [[1,3,3], [7,5,2]]print(np.argmax(x))#返回索引位置3对于这个例子我们知道，7最大，索引位置为3(这个索引按照递增顺序)！axis属性axis=0表示按列操作，也就是对比当前列，找出最大值的索引！x = [[1,3,3], [7,5,2]]print(np.argmax(x,axis=0))[1 1 0]x = [[1,3,3], [7,5,2]]print(np.argmax(x,axis=0))[1 1 0]那如果碰到重复最大元素？返回第一个最大值索引即可！x = np.array([1, 3, 2, 3, 0, 1, 0])print(x.argmax())1 求取精度 1np.around([-0.6,1.2798,2.357,9.67,13], decimals=0)#取指定位置的精度 1array([-1., 1., 2., 10., 13.]) 看到没，负数进位取绝对值大的！ ```pythonnp.around([1.2798,2.357,9.67,13], decimals=1) ​array([ 1.3, 2.4, 9.7, 13. ]) ​ ​np.around([1.2798,2.357,9.67,13], decimals=2) ​ ​array([ 1.28, 2.36, 9.67, 13. ]) ​ 从上面可以看出，decimals表示指定保留有效数的位数，当超过5就会进位(此时包含5)！ 但是，如果这个参数设置为负数，又表示什么？ np.around([1,2,5,50,56,190], decimals=-2) array([ 0, 0, 0, 0, 100, 200]) 看到没，必须看两位，超过50才会进位，190的话，就看后面两位，后两位90超过50，进位，那么为200！ 计算沿指定轴第N维的离散差值 x = np.arange(1 , 16).reshape((3 , 5)) print(x) [[ 1 2 3 4 5] [ 6 7 8 9 10] [11 12 13 14 15]] np.diff(x,axis=1) #默认axis=1 array([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) np.diff(x,axis=0) array([[5, 5, 5, 5, 5], [5, 5, 5, 5, 5]]) 取整 np.floor([-0.6,-1.4,-0.1,-1.8,0,1.4,1.7]) array([-1., -2., -1., -2., 0., 1., 1.]) 看到没，负数取整，跟上述的around一样，是向左！ 取上限 np.ceil([1.2,1.5,1.8,2.1,2.0,-0.5,-0.6,-0.3]) array([ 2., 2., 2., 3., 2., -0., -0., -0.]) 取上限！找这个小数的最大整数即可！ 查找 利用np.where实现小于0的值用0填充吗，大于0的数不变 x = np.array([[1, 0], [2, -2], [-2, 1]]) print(x) np.where(x&gt;0,x,0) array([[1, 0], [2, 0], [0, 1]]) ```","categories":[],"tags":[]},{"title":"linux_cleanfile","slug":"linux-cleanfile/linux-cleanfile","date":"2020-10-20T07:27:15.000Z","updated":"2020-11-16T13:33:31.985Z","comments":true,"path":"2020/10/20/linux-cleanfile/linux-cleanfile/","permalink":"http://xiaomuhou.github.io/2020/10/20/linux-cleanfile/linux-cleanfile/","excerpt":"由Linux-bug文件清理以及删除想到的linux多版本软件安装想法理解记录昨天晚上测试运动算法包，更新中间发现系统磁盘爆满，终端terminal无法运行，启动文件节点无法启动，于今天下午解决问题，写一篇日志记录一下，顺便谈一下linux的多版本软件安装基理。","text":"由Linux-bug文件清理以及删除想到的linux多版本软件安装想法理解记录昨天晚上测试运动算法包，更新中间发现系统磁盘爆满，终端terminal无法运行，启动文件节点无法启动，于今天下午解决问题，写一篇日志记录一下，顺便谈一下linux的多版本软件安装基理。 启动terminal，显示终端内存不足，导致文件无法启动，猜想原因是点击系统更新中断后产生bug文件，使得根目录爆满，这里介绍一条指令便于分析大内存位置： Traceback (most recent call last): File “/opt/ros/kinetic/_setup_util.py”, line 297, in sys.stdout.flush()IOError: [Errno 28] No space left on deviceFailed to run ‘“/opt/ros/kinetic/_setup_util.py” ‘: return code 1Traceback (most recent call last): File “/home/xiaomu/ws_moveit/devel/_setup_util.py”, line 297, in sys.stdout.flush() 首先 df -h 或者 df -hi查看linux总分区，寻找剩余空间不多的分区，我的是根目录显示爆满 1/dev/sda9 23G 22G 0 100% / 输入 1sudo du -h -x --max-depth=1 比如我的显示 var与usr文件爆满 1234567891011121314151617181913M ./sbin16K ./lost+found4.0K ./mnt4.0K ./lib6420M ./root9.9G ./var775M ./lib8.0K ./media4.6M ./libx323.9M ./lib3216K ./snap1.2G ./opt16M ./etc9.8G ./usr4.0K ./srv60K ./tmp13M ./bin4.0K ./cdrom22G . 根据信息对相应文件进行删除，小心误删重要文件 var文件夹系统运行后占用硬盘内存，主要针对常态性变动文件，包括缓存、登录文件、以及某些软件运行所产生的文件等，log中放置登录文件日志 /var的意义与内容 如果/usr是安装时会占用较大硬盘容量目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。因为/var目录主要针对常态性变动文件，包括缓存（cache）、登录文件（logfile）以及某些软件运行所产生的文件，包括程序文件（lock file，run file），或者例如Mysql数据库的文件等。常见的子目录如下： /var/cache：应用程序本身运行过程中会产生生的一些暂存文件。 /var/lib:程序本身执行的过程中需要使用到的数据文件放置的目录。再次目录下各自的软件应该要有各自的目录。举例来说，Mysql的数据库放置到/var/lib/mysql，而rpm的数据库则放到/var/lib/rpm目录下。 /var/lock:某些设备或者是文件资源一次只能被一个应用程序所使用 ，如当系统中有一个刻录机两个人都要使用，那么需要在一个人使用的时候上锁，那么第一个人使用完毕后，第二个人才可以继续使用。 /var/log:这个是登录文件放置日志的的目录。里面比较重要的文件/var/log/messages，/var/log/harry(记录登陆者信息)等。 /var/run/：某些程序启动服务后，会将他们PID放置在这个目录下。 ——来源—-https://www.cnblogs.com/Renyi-Fan/p/11504111.html （本次问题主要出现在这里，推测由于中断更新，导致产生了两个大的错误日志，经过上述方法，在log中发现了两个4g多的日志文件，进行了强制删除，系统恢复正常） 文件分别为syslog以及kern.log，这里删除后注意重启服务 service syslog restart 至此，问题已经解决，过程中发现usr文件夹同样较大，其实没有问题，原因是因为我平时跑ros以及各种图像代码，库中安装了多个版本的软件，当初只是按照教程进行安装，却不知道为什么linux可以这样，今天知道了原因： usr文件夹 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/ 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 —-来源—-https://www.cnblogs.com/ftl1012/p/9278578.html 关于local文件夹，依据上述介绍，同理可以手动进行其余软件多版本的安装。 总之，个人觉得ubuntu更新还是慎重，其次，装双系统的时候尽量空间给多一点，学会随时终端查看磁盘存储情况，根据报错解决问题，最后写一下查看磁盘的终端命令指南： df df以磁盘分区为单位查看文件系统 显示内容参数说明： Filesystem：文件系统 Size： 分区大小 Used： 已使用容量 Avail： 还可以使用的容量 Use%： 已用百分比 Mounted on： 挂载点 Linux 查看磁盘空间Linux 查看磁盘空间可以使用 df 和 du 命令。 dfdf 以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 例如，我们使用df -h命令来查看磁盘信息， -h 选项为根据大小适当显示： 显示内容参数说明： Filesystem：文件系统 Size： 分区大小 Used： 已使用容量 Avail： 还可以使用的容量 Use%： 已用百分比 Mounted on： 挂载点 相关命令： df -hl：查看磁盘剩余空间 df -h：查看每个根路径的分区大小 du -sh [目录名]：返回该目录的大小 du -sm [文件夹]：返回该文件夹总M数 du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹） dudisk usage ，查看磁盘的使用情况 查看当前目录的总大小 1# du -sh du 命令用于查看当前目录的总大小： -a或-all 为每个指定文件显示磁盘使用情况，或者为目录中每个文件显示各自磁盘使用情况。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或–total 除了显示目录或文件的大小外，同时也显示所有目录或文件的总和。 -D或–dereference-args 显示指定符号连接的源文件大小。 -h或–human-readable 以K，M，G为单位，提高信息的可读性。 -H或–si 与-h参数相同，但是K，M，G是以1000为换算单位,而不是以1024为换算单位。 -k或–kilobytes 以1024 bytes为单位。 -l或–count-links 重复计算硬件连接的文件。 -L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。 -m或–megabytes 以1MB为单位。 -s或–summarize 仅显示总计，即当前目录的大小。 -S或–separate-dirs 显示每个目录的大小时，并不含其子目录的大小。 -x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。 –exclude=&lt;目录或文件&gt; 略过指定的目录或文件。 –max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。 –help 显示帮助。 –version 显示版本信息。 本文中用到的两个指令： 123df -hsudo du -h -x --max-depth=1 清理缓存以下资料来源于，转载非原创 https://www.sysgeek.cn/ubuntu-free-up-space/ 1.移除不再需要的软件包 如果你了解过 apt-get 或 apt 命令的详细用法，应该知道 autoremove 选项。此选项可以删除「安装某个软件包时」自动安装的依赖库和包，这些自动安装的依赖包在系统中通常是无用的，只用浪费磁盘空间。当然，autoremove 选项也可以自动删除那些系统升级过程中被取代的老旧无用 Linux 内核。 这是一个自动化的傻瓜命令，可以时不时用它为 Ubuntu 系统释放一些可用硬盘空间： 1sudo apt autoremove 2. 清理Ubuntu中的APT缓存Ubuntu 使用 APT（高级软件包工具）在系统上安装、删除和管理软件，并且在软件卸载之后它还会保留先前下载和安装软件包的缓存。 APT 包管理系统会将下载的 DEB 包缓存在 /var/cache/apt/archives 文件中，随着时间的推移，由于拥有大量不需要的包这个缓存目录可以增长得相当大。 你可以使用以下命令查看此缓存的大小： 1sudo du -sh /var/cache/apt 对于 APT 缓存我们有两种可选方式对其进行清理，其一为只删除过时的软件包： 1sudo apt autoclean 另一种则是清理整个缓存（释放更多的磁盘空间）： 1sudo apt clean 3.清理缩略图缓存为方便用户预览图片，Ubuntu 会自动为图片文件创建一个缩略图，用于在文件管理器中查看，而这些这些缩略图其实也是以文件形式隐藏存储在用户账户的 ~/.cache/thumbnails 目录当中。 如果你是摄影爱好者或是图片收藏者，随着时间的推移，缩略图的数量将大大增加。特别需要注意的是，如果你删除了某些照片或图片，这些自动生成的缩略图缓存还是会存在于磁盘当中，而不会自动清除。 你可以使用以下命令检查缩略图缓存的大小： 1du -sh ~/.cache/thumbnails 因此，每几个月左右清除缩略图缓存是一个很好的习惯。 最快捷的方法就是使用终端命令： 1rm -rf ~/.cache/thumbnails/* 4.手动删除老旧Linux内核（专业）前面介绍第 1 种方法时就提到了可以自动删除那些老旧无用的 Linux Kernel，但如果你在 Ubuntu 中曾手动安装过内核，则 apt autoremove 命令选项则不适用了。但删除不使用的旧版内核确实又可节省大量磁盘空间，所以对于手动安装的 Ubuntu 内核可以进行手动卸载。 首先使用如下命令列出当前 Ubuntu 中所有已经安装的 Linux Kernel： 1sudo dpkg --list 'linux-image*'* 删除旧版内核与删除任何其他软件包一样： 1sudo apt remove linux-image-VERSION 5. 删除多余的孤立包（专业）首先我们要说说什么是 Ubuntu 系统中的孤立包（也叫多余的包）：假设你安装了一个名为 myprogram 的软件包，而这个包又依赖于 mylib 库，这个库通常在安装 myprogram 时便会自动安装到系统当中。当你卸载 myprogram 应用时，mylib 库可能仍然保留在系统中。 此种情况下，mylib 就会成为一个孤立的包。 gtkorphan 这款图形化应用可以可以轻松找出并删除 Ubuntu 系统中的孤立包，先使用如下终端命令进行安装： 1sudo apt install gtkorphan 安装好后在「多余的包」选项卡中即可对查找、删除孤立包。 6.卸载不必要的应用程序相信每个人都有那么一款和几款几乎不用的游戏或应用程序存在于系统当中。不相信？去你 Ubuntu 系统查下软件列表就知道了。其实这条也不用我多说，如果你需要更多的磁盘空间，删除那些从不使用或较少使用的应用程序总是一个好方法。 删除软件可以使用「Ubuntu 软件」或直接终端命令： 1sudo apt remove 软件包名 7. 使用GUI工具释放Ubuntu空间转载非原创 https://www.sysgeek.cn/ubuntu-free-up-space/","categories":[{"name":"linux","slug":"linux","permalink":"http://xiaomuhou.github.io/categories/linux/"}],"tags":[]},{"title":"manipulator_HU_learninging","slug":"manipulator-HU-learninging/manipulator-HU-learninging","date":"2020-10-12T07:37:58.000Z","updated":"2020-10-13T09:25:44.305Z","comments":true,"path":"2020/10/12/manipulator-HU-learninging/manipulator-HU-learninging/","permalink":"http://xiaomuhou.github.io/2020/10/12/manipulator-HU-learninging/manipulator-HU-learninging/","excerpt":"记录一套开发流程，没啥意义后续可看，ppt要好好做","text":"记录一套开发流程，没啥意义后续可看，ppt要好好做 1.基本理论 2.开发 ISO 机器人动作机构具有类似于人或其他生物体的某些器官（肢体、感受等）的功能；、 机器人具有通用性，工作种类多样，动作程序灵活易变； 机器人具有不同程度的智能性，比如记忆、感知、推理、决策、学习等； 机器人具有独立性、完整的机器人系统在工作中不可以依赖于人的干预。 驱动系统 电源子系统 电机驱动系统—控制信号-电信号 传感器 内部传感器 机器人里程计 惯性测量单元IMU 控制系统 PC—人机交互（SLAM、导航、图像识别、语音识别） TCP/UDP 硬件系统：控制、传感器数据采集、驱动系统通信、外设连接 外部传感器 外部摄像头、Kinect 激光雷达 移动机器人-常见 机器人架构可参考（ppt制作，针对特种环境的通信干扰分析） 云机器人架构思想： 全局云：全局数据存储、共享和交互 本地云：密集型计算的机器人应用服务 机器人：面向用户的终端服务单元 优点：局部网络占优 本地云数据共享更加灵活、快捷 数据保存与本地服务器，更加安全、可靠 服务于多种机器人 整理常见机械臂： UR机械臂，安全度高、编程简单、灵活度高，负载10-18kg，工作半径85-130cm。 控制框架架构+系统架构+云系统架构 开发具体流程分析与记录（代码分析）：1.常见基础 2.manipulator_moveit 3.moveit+gazebo 仿真系统搭建 ros_control 为开发者提供的机器人控制中间件，包含一系列控制器接口、传动器接口、硬件接口、控制器工具箱 包括有速度控制、位置控制、力控制 关节位置控制器：PID 具体参照arm包 yaml文件或者gazebo_control内yaml文件 加载控制器，加载conrollers关节参数，加载publisher参数节点，三部分，关节矩阵变换 moveit与gazebo rviz 联合仿真 编程接口 moveit_commander python接口 1.连接控制需要的规划组 2.设置目标位姿 3.设置运动约束 4.使用moveit！规划一条到达目标的轨迹 5.修改轨迹 6.执行规划出的轨迹 启动moveit包-moveit_config,程序中给出目标位置以及执行器位置信息，软件自动规划最优路径 编程—-针对规划组编写，设置目标位置参数，臂则设置位置信息，数组导入，完成机械臂规划 工作空间运动规划—轨迹规划(关键代码参数) 创建规划组的控制对象 获取机器人终端LINK名称 设置目标位姿对应的参考坐标系和起始、终止位姿 完成规划并控制机械臂完成运动 运动限制约束设置 运动学插件问题KDL，插件选用以及二次开发问题 抓取与放置，attach与un，避障规划 代码分析与移植待补充～～","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[]},{"title":"manipulator_review","slug":"manipulator-review/manipulator-review","date":"2020-10-02T07:45:08.000Z","updated":"2021-08-29T08:50:34.702Z","comments":true,"path":"2020/10/02/manipulator-review/manipulator-review/","permalink":"http://xiaomuhou.github.io/2020/10/02/manipulator-review/manipulator-review/","excerpt":"综述笔记-manipulator_review(underwater)-(system已补充结束)一篇综述[1]的总体方向笔记，非文献整理。 [1] SIVČEV S, COLEMAN J, OMERDIĆ E, et al. Underwater manipulators: A review [J]. 2018, 163(431-50. UUV-unmanned underwater vehicles ROV—remotely operated vehicles AUV-autonomous underwater vehicles UVMS-Underwater Vehicle Manipulator Systems","text":"综述笔记-manipulator_review(underwater)-(system已补充结束)一篇综述[1]的总体方向笔记，非文献整理。 [1] SIVČEV S, COLEMAN J, OMERDIĆ E, et al. Underwater manipulators: A review [J]. 2018, 163(431-50. UUV-unmanned underwater vehicles ROV—remotely operated vehicles AUV-autonomous underwater vehicles UVMS-Underwater Vehicle Manipulator Systems (水下双臂—一号臂抓取固定机器人本体，二号臂执行预定作业内容) 常见任务：1.管道检测 2.沉没物体打捞作业 3.矿井作业 4.清洁表面作业 5.开关阀门、钻探、rope cutting 6.线缆铺设以及维修 7.清理碎片或渔网 8.生物地质采样 9.考古archaeological work 特殊环境材料选择（水下）作业约束： 1.the size of the workspace 2.lifting capacity 3.wrist torque 常用金属合金，比如TI6-4、阳极氧化铝、不锈钢合金以及某些塑料（聚乙烯） —较高强度、耐腐蚀性、良好的可加工性质、减轻水中的重量以及减少执行器负担 Reach—水下机械手运动链长 水下机械手能产生的最大腕部扭矩范围8NM-250NM 水下机械手的载荷5kg-500kg左右 水下机械手的运动范围为0.5m-2.4m 参数：max.nominal 最大额定值 at full extension 完全伸展 at rated speed 额定速度 through envelope 关于水下控制模型意义机械手的质量尽量占比较小，为了可以忽略或至少将动态耦合考虑为可以解决的外部干扰，通过水下机器人的动态定位，更大的重量和尺寸对水下机器人推进器系统对由动态耦合引起的干扰的鲁棒性提出了更高的要求。 机械爪通常设计三到六个自由度，三个自由度可以到达任意位置，六个自由度可以实现末端执行器的任意位置和方向 高自由度具有冗余性，常用于避障作业 驱动 海水驱动，缺点较多被放弃 液压驱动— 高负载，高效率、简单、过载保护 定位精度差、容易泄露造成污染 电驱动 电动用于商业较少，难以满足工业速度、可靠性、强度或力量要求 电液混合驱动 以上电与液压驱动均有大量研究文章，有时间挑着看看商用水下操纵器控制系统安装在ROV上的商用水下操纵器由遥操作系统控制，并且完全依赖于位于水面船只上的回路中的驾驶员/操纵员。 飞行员通过摄像头和/或声纳系统的反馈来观察场景，并同时做出有关运动的决定，并使用一些备用输入设备之一远程操作水下操纵器。 根据水下机械手的技术能力，使用不同的控制方法。 商业用控制系统商业级别一般使用遥操作 rate control 液压通过流量与速度控制 position control 位置传感器通过电位计、analog resolvers、digital optical encoders 、solid state linear position sensors force feedback 商业级应用，常用于辅助人工操作 gripper control 水下理论控制模型（文章较多，研究重点）manipulator作为一种多体动力学问题，控制方案包含集中控制与分散控制方案两类，此外还包括神经网络控制模型。 浮力、增加的质量、耗散的阻力和升力以及外部干扰（电流、波浪等），增加了非线性与不确定性因素，使得建模控制变得更加复杂。此外水动力系数无法估计，因为他们会随着温度、深度、盐度等变化，当人体通过液体加速时，水体产生格外的惯性，即质量附加效应 波浪、海流和潮汐导致流体加速，导致外部和运动干扰以及机械手和机器人的强烈震荡和负载，最后在机器人与机械臂之间发生强烈的运动学和动力学耦合效应 分散控制—PID 集中控制—非线性集中控制方案 多层神经网络控制器 基于非回归的自适应控制器 基于滑膜控制策略和动力学模型的水下机器人鲁棒轨迹跟踪控制器等等（—后续记录） 神经网络模糊控制 利用模糊增益调整在不确定性和扰动下实现自适应，神经网络用于逼近水下机械手的动力学并添加前馈，补偿输入到PD模糊控制器 运动控制探讨（高级控制）传统：水下航行器与机械臂是分开协调的，因此将整个系统视为两个独立系统。 特殊环境下的耦合需要采用高级控制方案 针对耦合动力问题进行探讨（方案细节见技术综述笔记，个人认为这里可以进行改进研究） 有一种不错的思路，控制重心而非机器人具体姿态 整体系统控制-基于鲁棒的自适应控制方案 反馈、前馈控制器（方案细节见技术综述笔记） 总体而言，水下控制模型主要处理的就是由于水下特殊环境引起的干扰以及特殊环境下的运动耦合 运动控制与规划（路径规划与轨迹规划-笛卡尔遥操作方案 这里注意一下2013年沈阳自动化所提出的六自由度水下机械臂控制策略 2018年的碰撞检测算法 触觉交互 冗余解析度 通过不同次要目标解决冗余分辨率，避免关节限制、奇异性、高关节速度，将末端执行器保持在机载摄像头视线范围 内，将阻力最小化 理想与实际大多基于关节空间设定点进行工作，但是需要位置、速度和加速度的详细信息反馈跟踪 电动具有高效率优势 Force control关于被动与主动顺应性控制、阻抗控制和混合阻抗控制，这里注意一下1996年的针对水下环境的混合力位控制的方案 Conclusion问题：高质量的传感器与驱动器组成机器人系统，但是控制系统能力不足，可建议讲工业制造中使用的机器人手臂伺服控制只是引入水下环境。 低精度、低重复性、低控制环路频率 控制算法本身存在问题，缺乏与实际的结合与改进 这里注意下国外实验室的一个项目（细节见技术笔记） 提出了两种思路 将车辆导航与定位数据用于机械手控制，补偿运动误差系统 从机械角度出发，一种稳定器（从末端执行器角度考虑） 目的：简化操作 总而言之，文章一直在说一个问题，就是关于高级控制方案落地的问题，个人觉得很类似理论控制的现状，不过嘛，人人都有自己的目的想法，就这样吧。 后续会补充一篇系统综述机器人系统-深入了解水下机器人技术、产品和应用 ROV深海采矿作业 AUV-长期运行能力、深水深处返回数据的能力 水下声学定位系统 悬停方向的AUV，悬停运动由于同时使用水平推进器和垂直推进器完成 水下滑翔机 始于军事，拓展为海上油气等等，比如海上搜索和救援、海洋学等 未来展望","categories":[{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"}],"tags":[]},{"title":"delta_ros","slug":"delta-ros/delta-ros","date":"2020-09-11T11:18:01.000Z","updated":"2020-09-11T12:45:23.196Z","comments":true,"path":"2020/09/11/delta-ros/delta-ros/","permalink":"http://xiaomuhou.github.io/2020/09/11/delta-ros/delta-ros/","excerpt":"","text":"记录delta算法 （1）实现了Delta型机器人的正逆运动学及其速度空间变换，见DeltaRobotKinematics类（2）实现了关节空间和直线轨迹的运动规划，能够设置加减速因子，见DeltaRobotMotionPlanning类（3）实现了Delta机器人的位置控制和速度控制，见DeltaRobotControl类 https://github.com/zhonghang1187151422/Mini-delta-robot.git https://github.com/manuelilg/eeduro_delta.git https://github.com/RemcoKuijpers/delta_robot_simulation.git https://github.com/AutoRoboCulture/delta-robot-simulation-gazebo 关于ros2的delta运动规划 https://github.com/manuelilg?tab=repositories 学习一下","categories":[],"tags":[]},{"title":"literature","slug":"literature/literature","date":"2020-09-03T09:55:24.000Z","updated":"2020-09-03T11:28:18.014Z","comments":true,"path":"2020/09/03/literature/literature/","permalink":"http://xiaomuhou.github.io/2020/09/03/literature/literature/","excerpt":"复习科技文献结构内容大量阅读英文期刊还是需要短时间提取有效内容，复习一下论文规则，提提速，有点忘记了 abstract consult discussion method result review","text":"复习科技文献结构内容大量阅读英文期刊还是需要短时间提取有效内容，复习一下论文规则，提提速，有点忘记了 abstract consult discussion method result review Abstract​ An abstract is a brief summary of the key points of a research article, thesis, review, report, proposal,conference proceeding, or any in-depth analysis of a particular subject. Positioned at the beginning of a paper, the abstract is usually “the first thing that individuals read and, as such, decide whether to continue reading. It is also what is most accessed by search engines and researchers conducting their own literature reviews” 摘要分层 1.background 2.problem 3. method 4.results 5.conclusion sense：比较通用，可以回忆一下自己写过的毕业论文，摘要部分基本就是这个结构，先介绍简要背景，提出其中要解决的问题，我们用了什么方案去解决，结果如何，得出了什么结论，最后论文结尾加展望，这里没有。 Types of abstracts1.information abstract 2.indicative abstract 常用于 theoretical papers review articles commentary articles conference proceedings 3.extended abstract thesis dissertation 4.structured abstract 5.conference abstract 6.graphical abstract 7.executive summary The Disscussion Sectiondifference Introduction The discussion section of a research paper is:• To interpret the results of research• To analyze and discuss the results• To answer the questions proposed in the study• To draw conclusions from the findings of the study The discussion section is featured of• following the results section• calling attention to something not directly apparentfrom the table, chart or graph• analyzing data to support the thesis of the researchquestion• relating to what is discussed in the introduction section 分层 1.review of the present study 2.consolidating ofthe results 3.stating limitations and possible research directions 同样可以回忆一下，先对全文总结，其次阐述自己的实验结果，最后说一下自己项目的局限性以及未来努力方向 Method Components of the method section• Research design• Materials• Procedure• Data collection• Data analysis 分层 Move 1: WHEN the study was carried outMove 2: WHERE the study was carried outMove 3: WHAT materials, techniques, samples, data,approaches, theoretical frameworks were used in thestudyMove 4: HOW the study was carried outMove 5: WHAT procedures were used 一些特点 linguistic features • using the third person• passive voice• past tense• complete sentences• objective• concise Method classification 1) Logical methods:InductiveDeductiveAnalogicalAnalytical 2) Empirical methodsObservationalExperimentalMeasuringstatistical 3) Mathematical methods:MathematicalSimulativeIdealizedHypothetical Based on purposes• Basic research• Applied research• Developmental research …用的比较少，不列了 缺一部分，改天再补，回寝了～","categories":[],"tags":[]},{"title":"","slug":"ros-work/ros-work","date":"2020-08-25T01:13:55.000Z","updated":"2020-10-12T07:36:55.687Z","comments":true,"path":"2020/08/25/ros-work/ros-work/","permalink":"http://xiaomuhou.github.io/2020/08/25/ros-work/ros-work/","excerpt":"时隔一年，再次听胡老师的课，感受颇有不同，包括简要课程记录复习一下以及写写作业。 (9.26添加了一些小内容) (10.12增加了一下go内容)","text":"时隔一年，再次听胡老师的课，感受颇有不同，包括简要课程记录复习一下以及写写作业。 (9.26添加了一些小内容) (10.12增加了一下go内容) 1.日常ROS史观 2.ros框架以及松耦合的分布式通信机制（日常） 3.节点-执行单元（node） 节点管理器（ros master） Topic-异步通信机制（publisher/subscriber） 先来后到，多对多 service-同步通信机制（service/client）—-request response 请求之后才会应答，一对多 参数（parameter） 典型字典 工作空间（workspace0 src:代码空间 build:编译空间 devel:开发空间 install: 安装空间 功能包（package） 功能包清单（package manifest ）（包含作者信息、许可信息等，好像一直没用过这个233） 元功能包（meta packages） action通信及机制 应用场景：比如抓取，一段时间的抓捕动作，在执行过程中需要连续的response 日常启动turtle 关于turtlebot ———-没有作业0.0 ros常用组件与开发 roslog ros_moveit记录：manipulator 多轴机械臂6.7+各式夹具 六轴机械臂 伺服电机（减速机，为了降低电机转速，从而增加电机扭矩）皮带、行星、谐波（成本减速器比较高） 机械臂本体 控制器 成本占比图 智能化处理 moveit 运动学、运动规划、碰撞检测、 motion planning、manipulation、inverse kinematics control、3dperception（3d视觉）、collsion碰撞检测 核心节点 move_group 输入输出参数 move_base 话题发布-cmdvel 用户interface Ros moveit 自己算法可封装到plugins Moveit 可视化配置和仿真 Planning scene点云栅格地图 Roslaunch moveit setup assistant 1.选择模型，导入urdf或者xacro，需要严格按照DH法进行建立模型，导入moveit位置姿态正常。 2.设置自碰撞检测 self collsion 虚拟关节 vitual joints 描述机械臂基础坐标，固定臂虚拟项不修改，若移动，需要对虚拟关节修改。 3.配置规划组 运动学求解算法 规划失败：模型没问题，规划时间可能太短，我好像没遇到过哎 规划组选择最为重要 4.预定义位姿 可设置初始姿态或者某些特殊姿态 使用较多，rviz规划仿真 5..设置控制器 6.作者信息 7.生成配置功能包，使用较少 Demo.launch-rviz仿真 后续工作—gazebo Gazebo+ros+ros_control 电机闭环控制知识（待补充） Ros控制器接口 Moveit规划得到轨迹，通过controller（follow joint trajectory封装成话题action）—serve（默认五次插补运算）—伺服电机得到指令—硬件端-机器人对上位机反馈（joint state controller） 基础编程 1.连接控制需要的规划组 2.设置目标位姿，关节空间或者笛卡尔空间 3.设置运动约束 4.使用moveit规划以到达目标的轨迹 5.修改轨迹 5.执行规划出的轨迹 约束规划 点到点关节空间规划 (plan,fraction) = arm.compute_cartesian_path(waypoints,0.01,0.0,True) 路径列表、终端步进值、最小移动值、避障规划 Fraction 0-1 小于1无法规划 直线轨迹 圆弧轨迹方法：微分 碰撞检测 直接在可视界面添加障碍物 通过代码导入 API 五核心 抓到物体 attach Eye in hand 手眼标定（内参，外参） 物体识别与定位（） 抓取姿态分析（） 运动规划 Eye to hand Eye in hand 关于ros： 像素坐标转换成全局空间坐标 深度学习融合 ROS-I 工业机械臂应用 工业领域分支 应用 ros_slam记录:1.slam-地图构建 gmapping 激光方案 vslam 视觉方案存在问题，容易受环境光影响，工业环境常用激光，irobot使用了视觉，精度要求不高 superpoint 多检测融合，包括orb、角点检测等，鲁棒性较高 pointcloud 点云设计方案 去除噪音、降采样、移除行人、移除地面—-网格mesh化 point—-legoloam—点云算法，运算量比较小，点云图像投影 地图构建之后，定位 EKF-扩展卡尔曼滤波器 信息融合，视觉、imu惯性测量单元（测量姿态）、gps等数据源卡尔曼滤波，提高精度 平面定位-amcl 粒子分布、更新—全局分布—视觉重定位（辅助）—初始定位—定位置信度 定位-NDT/ICP 点云算法 ndt 网格化正态分布变换 icp 迭代最近点 由轨迹确定位置 3.全局规划与局部规划 Globalcostmap 静态层、动态层、膨胀层（远离障碍物，自己加） 全局规划算法—A*/Dijkstra 目的是避障寻找最低能耗路径 人工势场法—寻找能量最低路径 地图构建-势场-膨胀-全局规划算法-跟随，进行局部规划算法 局部规划 以机器人周围构建主要激光和点云 算法-DWA（决定机器人动态效果） ​ 1.采样空间/运动模型 ​ 2.代价函数 ​ 防抖，运动平滑 ​ 3.动态窗口仿真 3.导航 move_base 4.全地形导航-height map 三维 存在高度概念 关于moveit计算方案 ros2记录（待续）:Rosi核心ros1 关于Ros2架构 Ros2起源，目的都是为了提高软件复用率 保密性不足，局域网下信息互通 2014年正式提出 2020.6.5 foxy fitzory 架构颠覆：ros1需要master管理，ros2使用基于DDS的discovery机制 Api重新设计：ros1基于2009.2之前 ros2重新设计了新的api，使用方法类似 编译系统升级：ros1 rosbuild、catkin ros2 ament colcon ros深度学习感知与控制 感知 物体分类 image 目标检测 object 语义分割 semantic 实例分割 instance 感知-cnn 卷积运算 池化运算 RCNN Mseg-语义分割 mask-rcnn感知 pointnet 2.联想GPT3 代码补全 数据集足够多，效果足够好 ROS探索总结记录（体系查漏补缺）package ROS 的软件以包的方式组织起来。包包含节点、ROS 依赖库、数据套、配置文件、第三方软件、或者任何其他逻辑构成。包的目标是提供一种易于使用的结构以便于软件的重复使用。总得来说,ROS 的包短小精干。 stack 堆是包的集合,它提供一个完整的功能 Manifests (manifest.xml):提供关于 Package 元数据,包括它的许可信息和 Package 之间依赖关系,以及语言特性信息像编译旗帜(编译优化参数)。Stack manifests (stack.xml):提供关于 Stack 元数据,包括它的许可信息和 Stack 之间依赖关系。 1.常见的几个 PR2 ：http://www.ros.org/wiki/Robots/PR2 Turtlebot：http://www.ros.org/wiki/Robots/TurtleBot Husky：http://www.ros.org/wiki/Robots/Husky / http://www.ros.org/wiki/Robots/Erratic 轮式移动机器人 手柄端口 ls /dev/input 机器视觉 rosrun rviz rviz 关于tf细节 (1) 监听 tf 变换 (2) 广播 tf 变换 关于无人车ros 总结 轮胎 纵向花纹： 低滚动阻力 防止侧滑，装向稳定性优异 横向花纹：出色的驱动力和制动力，强大的牵引力 纵横兼有花纹：纵纹提供向稳定性，横纹改善驱动力和制动力 关于usb问题： ls /dev/ttyUSB* ROSGO","categories":[],"tags":[]},{"title":"daliy_life","slug":"daliy-life/daliy-life","date":"2020-08-17T10:49:18.000Z","updated":"2020-08-18T10:52:49.089Z","comments":true,"path":"2020/08/17/daliy-life/daliy-life/","permalink":"http://xiaomuhou.github.io/2020/08/17/daliy-life/daliy-life/","excerpt":"","text":"处事之则，日常所想搭模型的时候，听了听电视剧琅琊榜的电台，听到景睿的台词，有点感触，为人处世就应该这样，清清爽爽，潇洒一生。 不为蝇营狗苟之事，不对他人做过分之求，一切唯心而已。 “曾经因为你这么做，非常难过。可是我毕竟已经，不再是一个自以为是的孩子了。我明白了，凡是人总有取舍，你取了你认为重要的东西，舍弃了我，这只是你的选择而已。若是我，因为没有被选择，就心生怨恨，那这世间，岂不是有太多不可原谅之处，毕竟谁也没有责任要以我为先，以我为重。无论我如何希望也不能强求。我之所以这么待你，是因为我愿意，若能以此换回同样的诚心，固然可喜，若是没有，我也没有什么可后悔的。”","categories":[{"name":"touch_fish","slug":"touch-fish","permalink":"http://xiaomuhou.github.io/categories/touch-fish/"}],"tags":[]},{"title":"delta_matlab","slug":"delta-matlab/delta-matlab","date":"2020-08-13T10:44:58.000Z","updated":"2020-08-13T11:22:22.898Z","comments":true,"path":"2020/08/13/delta-matlab/delta-matlab/","permalink":"http://xiaomuhou.github.io/2020/08/13/delta-matlab/delta-matlab/","excerpt":"Delta正逆解（matlab）课题里用到一部分关于delta底座的结构，所以进行了相应的理论推导及运动空间求解，工具是万能的matlab，这里记录一下。 记录内容：目前精度、推导问题、相关文献…","text":"Delta正逆解（matlab）课题里用到一部分关于delta底座的结构，所以进行了相应的理论推导及运动空间求解，工具是万能的matlab，这里记录一下。 记录内容：目前精度、推导问题、相关文献… 初步代码正逆解精度： 电机转角误差在0.1度左右，坐标误差在毫米个位数级别，感觉没有特别精确，师兄那套复杂并联都小数点后三位级别了，但是我目前想不到对算法进行优化的方式，不过先搁置吧，先去做绳驱那部分的机构，最后再回来优化。 推导来源： 正解理论依据我看的是工大03年赵杰老师的一篇期刊，应用平移几何进行简化，用向量实现对于动平台中心点运动状态的描述 （这里有个小问题，看期刊的时候，几何向量中求解垂直向量时，期刊里的公式是错的（也有可能03年就是错误公式？？？），哈哈哈，这里我换了一种平移方式，构成多面体进行解析） 逆解理论来源是16年黄师兄的硕士毕业论文，借鉴了一下他的单几何方式，组成方程组进行求解，这个方式得出的结果精度也比较高。 误差主要来源于正解，现在不知为什么，以后待解决。 以下是代码主体，参数不放了 正解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function [Z] = FK3(a1,a2,a3)RrLacLbctheta1 = a1*pi/180;theta2 = a2*pi/180;theta3 = a3*pi/180;*beta1=(1-1)*2*pi/3;beta2=(2-1)*2*pi/3;beta3=(3-1)*2*pi/3; OA1=R*[cos(beta1);sin(beta1);0];OA2=R*[cos(beta2);sin(beta2);0];OA3=R*[cos(beta3);sin(beta3);0];OE1=R*[(R-r+Lac*cos(theta1))*cos(beta1);(R-r+Lac*cos(theta1))*sin(beta1);-Lac*sin(theta1)];OE2=R*[(R-r+Lac*cos(theta2))*cos(beta2);(R-r+Lac*cos(theta2))*sin(beta2);-Lac*sin(theta2)];OE3=R*[(R-r+Lac*cos(theta3))*cos(beta3);(R-r+Lac*cos(theta3))*sin(beta3);-Lac*sin(theta3)];OG=0.5*(OE1+OE2);E1E2=OE2-OE1;E2E3=OE3-OE2;E3E1=OE1-OE3;a=norm(E1E2); b=norm(E2E3);c=norm(E3E1);p=(a+b+c)/2;s=sqrt(p*(p-a)*(p-b)*(p-c));%E1E2E3 d=(a*b*c)/(4*s);f=(d^2-0.25*a^2);if f&gt;=0 #这里进行筛选，开始出现复数结果还很奇怪233，这个可以解决 f1=sqrt(f); n_GF1=cross(cross(E2E3,E3E1),E1E2); g=norm(n_GF1); n_GF = n_GF1/g; GF= n_GF*f1;n_FP1=cross(E1E2,E2E3);h=norm(n_FP1);n_FP=n_FP1/h;%FP |FP|i=sqrt(Lbc^2-d^2);FP = n_FP*i;OP=0.5*(OE1+OE2)+GF+FP;S=OP; e1=[1;0;0]; e2=[0;1;0]; e3=[0;0;1]; x=S'*e1; y=S'*e2; z=S'*e3;Ponit=[x,y,z]else disp('空间外'); return;end 逆解代码： 1234567891011121314151617181920212223242526272829303132333435363738function [thetas] = IK3(x,y,z)R rLac Lbc p=[x;y;z];beta1=(1-1)*2*pi/3;beta2=(2-1)*2*pi/3;beta3=(3-1)*2*pi/3; %OP=OA+AC+CB+BP%OP-OA+PB-Lac*n_AC=Lbc_n_CB% N_AC1=[cos(beta1)cos(theta1)];r1=-2*Lac*(cos(beta1)*(x+(r-R)*cos(beta1))+sin(beta1)*(y+(r-R)*sin(beta1)));r2=-2*Lac*(cos(beta2)*(x+(r-R)*cos(beta2))+sin(beta2)*(y+(r-R)*sin(beta2)));r3=-2*Lac*(cos(beta3)*(x+(r-R)*cos(beta3))+sin(beta3)*(y+(r-R)*sin(beta3)));s1=2*Lac*z;s2=2*Lac*z;s3=2*Lac*z;t1=(x+(r-R)*cos(beta1))^2+(y+(r-R)*sin(beta1))^2+z^2+Lac^2-Lbc^2;t2=(x+(r-R)*cos(beta2))^2+(y+(r-R)*sin(beta2))^2+z^2+Lac^2-Lbc^2;t3=(x+(r-R)*cos(beta3))^2+(y+(r-R)*sin(beta3))^2+z^2+Lac^2-Lbc^2;%rcostheta+ssintheta+t=0;if t1-r1==0 theta1=2*atan((-r1-t1)/(2*s1));else theta1=2*atan((-s1-sqrt(r1^2+s1^2-t1^2))/(t1-r1));endif t2-r2==0 theta2=2*atan((-r2-t2)/(2*s2));else theta2=2*atan((-s2-sqrt(r2^2+s2^2-t2^2))/(t2-r2));end if t3-r3==0 theta3=2*atan((-r3-t3)/(2*s3));else theta3=2*atan((-s3-sqrt(r3^2+s3^2-t3^2))/(t3-r3));endthetas=[theta1;theta2;theta3]*180/pi; （待优化） 关于8组逆解的问题，这套方案已经进行了排除。 奇异位置分析内容（待补充）。 接下来写雅各比速度推导，后续还会补充控制方案，伸缩机构可能会写一篇，看设计的情况了。","categories":[],"tags":[]},{"title":"Ros_sdk","slug":"Ros-sdk/Ros-sdk","date":"2020-08-07T01:25:27.000Z","updated":"2020-08-07T13:05:13.092Z","comments":true,"path":"2020/08/07/Ros-sdk/Ros-sdk/","permalink":"http://xiaomuhou.github.io/2020/08/07/Ros-sdk/Ros-sdk/","excerpt":"SDK_ros版本代码记录","text":"SDK_ros版本代码记录 arm.yaml 参数记录 xm540_w270 Protocol: 2 Return_Delay_Time: 100 #0~254 Operating_Mode: 3 #Position Control Mode Profile_Acceleration: 10 #time Profile_Velocity: 40 Shutdown: 33 #00100001 Input Voltage Error/Overload Error(default) 最大负载 Protocol: 2 Return_Delay_Time: 100 Operating_Mode: 3 Profile_Acceleration: 10 Profile_Velocity: 40 Velocity_Trajectory: Shutdown: 33 Min_Position: 625 #0~4095 Max_Position: 3409 Velocity_Limit: 40 这些值将位置控制模式（联合模式）的最大和最小期望位置限制在1转（0〜4,095）的范围内。因此，目标位置（116）应该配置在位置限制范围内。在扩展位置控制模式和基于电流的位置控制模式中不使用这些值。 Protocol: 2 Shadow_ID: 5 #？ Return_Delay_Time: 100 Operating_Mode: 3 Profile_Acceleration: 10 Profile_Velocity: 40 # Velocity_Trajectory: Shutdown: 33 Drive_Mode: 1 Min_Position: 625 Max_Position: 3409 Velocity_Limit: 40 ～～～～～～～～～～～～～～手动分割线 Protocol: 1 Return_Delay_Time: 100 Min_Position: 0 Max_Position: 1023 Max_Torque: 200 Torque_Limit: 200 辅助id不反馈数据包 初始位置参数表.yaml 底层代码+launch文件（节点）example node:joint_publisher 初始化设定臂与爪的初始位置home ping：protocol2.0协议，连接dynamixel ，同read_write 示例文件，初始化、参数设定与连接使能 src and launch dynamixel—电机参数表，model_number ,电机型号参数以及协议选择，原代码 MX与AX XM540-W150对应参数：270同 ​ 1130: { ​ “Return_Delay_Time”: ModelFlag(9, 1), ​ “Drive_Mode”: ModelFlag(10, 1), ​ “Operating_Mode”: ModelFlag(11, 1), ​ “Shadow_ID”: ModelFlag(12, 1), ​ “Velocity_Limit”: ModelFlag(44, 4), ​ “Max_Position”: ModelFlag(48, 4), ​ “Min_Position”: ModelFlag(52, 4), ​ “Shutdown”: ModelFlag(63, 1), ​ “Torque_Enabled”: ModelFlag(64, 1), ​ “Goal_Velocity”: ModelFlag(104, 4), ​ “Profile_Acceleration”: ModelFlag(108, 4), ​ “Profile_Velocity”: ModelFlag(112, 4), ​ “Goal_Position”: ModelFlag(116, 4), ​ “Moving”: ModelFlag(122, 1), ​ “Present_Current”: ModelFlag(126, 2), ​ “Present_Velocity”: ModelFlag(128, 4), ​ “Present_Position”: ModelFlag(132, 4), ​ “Present_Voltage”: ModelFlag(144, 2), ​ “Present_Temperature”: ModelFlag(146, 1), ​ “Velocity_Trajectory”: ModelFlag(136, 4) ​ }, 定义两种类型电机，我的只用了了一种xm540，控制模式不同，可改 协议1.0 2.0通用 将write与read定义到了类class中 功能：读取位置、转角并且转化数据，读取负载（使用protocol2.0），读取速度值并进行转化 current 温度值 位置？？？待修改 目标位置数值——-移动","categories":[],"tags":[]},{"title":"movie_fish","slug":"movie-fish/movie-fish","date":"2020-07-30T04:55:31.000Z","updated":"2020-08-18T10:57:30.524Z","comments":true,"path":"2020/07/30/movie-fish/movie-fish/","permalink":"http://xiaomuhou.github.io/2020/07/30/movie-fish/movie-fish/","excerpt":"观影清单来源（b站木鱼水心）","text":"观影清单来源（b站木鱼水心） V字仇杀队时隔多年再次欣赏这部电影，感觉平淡了许多，不再像当初那么愤青了。 世界上没有完美的事情，过于理性的审视一切，有很多好处，同时也失去了很多东西。 思想是不可消亡了～ 窃听风暴压抑的bgm，紧凑的情节 断续的信息流，完整的情感线，人类本质的体现 风云变换的历史，个人永远都是渺小的，滔天海浪的压迫感觉 百年未有之大变局，如何在历史的洪流中生活，放弃一些无用的主义思维，守好自己所相信的底线。 没有绝对的对错之分，安安静静的就好～ 黑客帝国三矩阵革命画面不错 银翼杀手套路一般，画面不错 I’ve seen things you people wouldn’t believe.Attack ships on fire off the shoulder of Orion.I’ve watched c-beams glitter in the dark near the Tannhauser Gate.All those … moments will be lost in time, like tears…in rain.Time to die. 我见过你们人类绝对无法置信的事物，我目睹了战船在猎户星座的端沿起火燃烧，我看着C射线在唐怀瑟之门附近的黑暗中闪耀，所有这些时刻，终将随时间消逝，一如眼泪消失在雨中。 不可触碰（跨越隔阂，消除歧视，单纯的友谊真是最美好的事情） （如果所谓的不平等是由自己的观点创造产生的，那么当你感觉或者想认为某件事或者某个人低等时，其实你自己已经立于深渊） （没有绝对的平等，也没有绝对的不平等，特别是偏见所创造的不平等） （生气的时候，有一点很重要，问自己一下，有必要么？）","categories":[],"tags":[]},{"title":"python100","slug":"python100/python100","date":"2020-07-28T07:23:03.000Z","updated":"2020-08-19T09:10:39.961Z","comments":true,"path":"2020/07/28/python100/python100/","permalink":"http://xiaomuhou.github.io/2020/07/28/python100/python100/","excerpt":"复习基础可用于复习语法基础，内容包括我自己一些解法，以及思路较新奇的解法，对一些不常用的函数进行了注释和以及代码示例。 可以对比学习python2和python3的区别，深化理解 网站上原作者解法应用了大量表达式简化代码行数，受益良多。 （万恶的ros有些还是python2呀，我也太菜了QAQ）","text":"复习基础可用于复习语法基础，内容包括我自己一些解法，以及思路较新奇的解法，对一些不常用的函数进行了注释和以及代码示例。 可以对比学习python2和python3的区别，深化理解 网站上原作者解法应用了大量表达式简化代码行数，受益良多。 （万恶的ros有些还是python2呀，我也太菜了QAQ） 1.编写一个程序，查找所有此类数字，它们可以被7整除，但不能是5的倍数（在2000和3200之间（均包括在内））。获得的数字应以逗号分隔的顺序打印在一行上。 divisible 123456789101112l=[]for i in range(2000, 3201): if (i%7==0) and (i%5!=0): l.append(str(i))print ','.join(l) #join用法，长知识#我的解法for i in range(2000, 3201): if (i%7==0) and (i%5!=0): print(i,end=',') #不换行打印\\b退格#网上的print(*(i for i in range(2000, 3201) if i%7 == 0 and i%5 != 0), sep=\",\") 2.编写一个可以计算给定数字阶乘的程序，结果应以逗号分隔的顺序打印在一行上，假设向程序提供了以下输入：8然后，输出应为：40320 我的解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445def fac(x): if x == 0: return 1 return x * fac(x - 1)x = int(raw_input())print fac(x) #没啥特别的#复习一下whilen=int(input())f=1,i=1while i&lt;=n: f=f*i i=i+1print(f)#复习forn = int(input()) fact = 1for i in range(1,n+1): fact = fact * iprint(fact)#short 0.0n = int(input())def shortFact(x): return 1 if x &lt;= 1 else x*shortFact(x-1)print(shortFact(n))#try语句while True:try: num = int(input(\"Enter a number: \")) breakexcept ValueError as err: print(err)org = numfact = 1while num: fact = num * fact num = num - 1print(f'the factorial of {org} is {fact}')#参数from functools import reducedef fun(acc, item): return acc*itemnum = int(input())print(reduce(fun,range(1, num+1), 1)) #reduce(function, iterable[, initializer])蛮好的思路，一维数组陈列 3.使用给定的整数n，编写一个程序以生成包含（i，i x i）的字典，该字典为1到n之间的整数（都包括在内）。然后程序应打印字典。假设向程序提供了以下输入：8 1234567891011121314151617181920212223242526272829n = int(input())d = dict()for i in range(1,n+1): d[i] = i * iprint d#othern = int(input())ans = {}for i in range (1,n+1): ans[i] = i * iprint(ans)n = int(input())ans={i : i*i for i in range(1,n+1)} #silentprint(ans)try: num = int(input(\"Enter a number: \"))except ValueError as err: print(err)dictio = dict()for item in range(num+1): if item == 0: continue else: dictio[item] = item * itemprint(dictio)num = int(input(\"Number: \"))print(dict(list(enumerate((i * i for i in range(num+1)))))) [x] QAQ 4.编写一个程序，该程序从控制台接受一个逗号分隔的数字序列，并生成一个列表和一个包含每个数字的元组，假设向该程序提供了以下输入：转化 12345678910111213values = input()l = values.split(\",\") #str.split(str=\"\", num=string.count(str)).t = tuple(l)print lprint tl.append(iter)lis = input().split(',')tup=tuple(lis)print(lis)print(tup)print(tuple(input(\"Enter a series of numbers separated by a comma:\").split(','))) 5.定义一个至少具有两个方法的类：getString：从控制台输入获取字符串 printString：以大写形式输出字符串。还请包括简单的测试函数来测试类方法。 提示：使用init方法构造一些参数 12345678910class IOstring(): def get_string(self): self.s = input() def print_string(self): print(self.s.upper())UP = IOstring()UP.get_string()UP.print_string() 6.编写一个程序，根据给定的公式计算并打印值： Q = [（2 C D）/ H]的平方根 以下是C和H的固定值： C为50。H为30。 D是变量，其值应以逗号分隔的顺序输入到您的程序中，例如，让我们假设以下逗号分隔的输入顺序被赋予了程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from math import sqrt # import specific functions as importing all using * # is bad practiceC,H = 50,30def calc(D): return sqrt((2*C*D)/H)D = [int(i) for i in input().split(',')] # splits in comma position and set up in list numberD = [int(i) for i in D] # converts string to integerD = [calc(i) for i in D] # returns floating value by calc method for every item in DD = [round(i) for i in D] # All the floating values are roundedD = [str(i) for i in D] # All the integers are converted to string to be able to apply join operationprint(\",\".join(D))from math import sqrtC,H = 50,30def calc(D): return sqrt((2*C*D)/H)D = input().split(',') # splits in comma position and set up in listD = [str(round(calc(int(i)))) for i in D] # using comprehension method. It works in order of the previous codeprint(\",\".join(D))QAQAQAQAQfrom math import sqrtC,H = 50,30def calc(D): return sqrt((2*C*D)/H)print(\",\".join([str(int(calc(int(i)))) for i in input().split(',')]))QAQAQAQAQfrom math import * # importing all math functionsC,H = 50,30def calc(D): D = int(D) return str(int(sqrt((2*C*D)/H)))D = input().split(',')D = list(map(calc,D)) # applying calc function on D and storing as a listprint(\",\".join(D)) 12345678910from math import sqrtC, H = 50, 30mylist = input().split(',')print(*(round(sqrt(2*C*int(D)/H)) for D in mylist), sep=\",\")from math import sqrtC, H = 50, 30mylist = input().split(',')print(*(round(sqrt(2*C*int(D)/H)) for D in mylist), sep=\"QAQ\")# end 与sep 单字母和列表 7._编写一个程序，该程序将X，Y两位数字作为输入并生成一个二维数组。 数组的第i行和第j列中的元素值应为i _ j。* python2 12345678910111213141516171819202122232425262728293031323334353637383940input_str = raw_input()dimensions = [int(x) for x in input_str.split(',')]row_num = dimensions[0]col_num = dimensions[1]multilist = [[0 for col in range(col_num)] for row in range(row_num)]for row in range(row_num): for col in range(col_num): multilist[row][col] = row * colprint multilist#python3x,y = map(int,input().split(','))lst = []for i in range(x): tmp = [] for j in range(y): tmp.append(i*j) lst.append(tmp)print(lst)#map(function, iterable, ...)&gt;&gt;&gt;def square(x) : # 计算平方数... return x ** 2... &gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方[1, 4, 9, 16, 25]&gt;&gt;&gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数[1, 4, 9, 16, 25] # 提供了两个列表，对相同位置的列表数据进行相加&gt;&gt;&gt; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])[3, 7, 11, 15, 19]x,y = map(int,input().split(','))lst = [[i*j for j in range(y)] for i in range(x)]print(lst) #单行 8.编写一个程序，该程序接受以逗号分隔的单词序列作为输入，并在按字母顺序对它们进行排序后以逗号分隔的顺序打印这些单词。 1234567items = [x for x in raw_input().split(',')]items.sort()print ','.join(items)lst = input().split(',')lst.sort()print(\",\".join(lst)) 9.编写一个接受行序列作为输入并在句子中的所有字符都大写之后打印行的程序。 python2 12345678910lines = []while True: s = raw_input() if s: lines.append(s.upper()) else: breakfor sentence in lines: print sentence python3 12345678910lst = []while True: x = input() if len(x)==0: break lst.append(x.upper())for line in lst: print(line) 12345678def user_input(): while True: s = input() if not s: return yield sfor line in map(str.upper, user_input()): print(line) 4.编写一个程序，该程序接受由空格分隔的单词序列作为输入，并在删除所有重复的单词并将其按字母数字顺序排序后打印这些单词。 1hello world and practice makes perfect and hello world again Then, the output should be:\\ 1again and hello makes perfect practice world python2 12345678910111213141516171819202122232425262728s = raw_input()words = [word for word in s.split(\" \")]print \" \".join(sorted(list(set(words)))) #set消除重复元素python3word = input().split()for i in word: if word.count(i) &gt; 1: word.remove(i) word.sort()print(\" \".join(word))#集合word = input().split()[word.remove(i) for i in word if word.count(i) &gt; 1 ] word.sort()print(\" \".join(word))word = sorted(list(set(input().split()))) print(\" \".join(word))#集合效果inp_string = input(\"Enter string: \").split()out_string = []for words in inp_string: if words not in out_string: out_string.append(words)print(\" \".join(sorted(out_string)))#不包含就存在 11.编写一个程序，该程序接受以逗号分隔的4位二进制数字序列作为输入，然后检查它们是否可被5整除。 被5整除的数字将以逗号分隔的顺序打印。 1class int(x, base=10) print(' '.join(value)) 参数 x — 字符串或数字。 base — 进制数，默认十进制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253value = []items=[x for x in raw_input().split(',')]for p in items: intp = int(p,2) if not intp % 5: value.append(p)print ','.join(value)python3def check(x): # total,pw = 0,1 reversed(x) for i in x: total+=pw * (ord(i) - 48) #ord(c)十进制 reversed(seq)翻转 pw*=2 return total % 5data = input().split(\",\") lst = []for i in data: if check(i) == 0: lst.append(i)print(\",\".join(lst))def check(x): return int(x,2)%5 == 0 data = input().split(',')data = list(filter(check,data)) print(\",\".join(data))filter(function, iterable)参数 function -- 判断函数。 iterable -- 可迭代对象。返回值返回列表。data = input().split(',')data = list(filter(lambda i:int(i,2)%5==0,data)) # lambda is an operator that helps to write function of one lineprint(\",\".join(data))data = input().split(',')data = [num for num in data if int(num, 2) % 5 == 0]print(','.join(data)) 12.编写一个程序，查找所有介于1000和3000之间的数字（都包括在内），以使数字的每个数字均为偶数。获得的数字应以逗号分隔的顺序打印在一行上。 str 12345678910111213141516171819202122232425262728293031323334values = []for i in range(1000, 3001): s = str(i) #字符 if (int(s[0])%2 == 0) and (int(s[1])%2 == 0) and (int(s[2])%2 == 0) and (int(s[3])%2 == 0): values.append(s)print \",\".join(values)lst = []for i in range(1000,3001): flag = 1 for j in str(i): # every integer number i is converted into string if ord(j)%2 != 0: # ord returns ASCII value and j is every digit of i flag = 0 # flag becomes zero if any odd digit found if flag == 1: lst.append(str(i)) # i is stored in list as stringprint(\",\".join(lst))def check(element): return all(ord(i)%2 == 0 for i in element) lst = [str(i) for i in range(1000,3001)] lst = list(filter(check,lst)) print(\",\".join(lst))lst = [str(i) for i in range(1000,3001)]lst = list(filter(lambda i:all(ord(j)%2 == 0 for j in i), lst)) # using lambda to define function inside filter functionprint(\",\".join(lst))******************888**'''Solution by: nikitaMogilev'''# map() digits of each number with lambda function and check if all() of them even# str(num) gives us opportunity to iterate through number by map() and join()print(','.join([str(num) for num in range(1000, 3001) if all(map(lambda num: int(num) % 2 == 0, str(num)))])) 13.编写一个接受句子并计算字母和数字数量的程序。 假设将以下输入提供给程序： python2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859s = raw_input()d = {\"DIGITS\":0, \"LETTERS\":0}for c in s: if c.isdigit(): #函数 d[\"DIGITS\"]+=1 elif c.isalpha(): d[\"LETTERS\"]+=1 else: passprint \"LETTERS\", d[\"LETTERS\"]print \"DIGITS\", d[\"DIGITS\"]python3word = input()letter,digit = 0,0#次级方案for i in word: if ('a'&lt;=i and i&lt;='z') or ('A'&lt;=i and i&lt;='Z'): letter+=1 if '0'&lt;=i and i&lt;='9': digit+=1print(\"LETTERS {0}\\nDIGITS {1}\".format(letter,digit))word = input()letter, digit = 0,0#最佳方案for i in word: if i.isalpha(): # returns True if alphabet letter += 1 elif i.isnumeric(): # returns True if numeric digit += 1print(f\"LETTERS {letter}\\n{digits}\") # two different types of formating method is shown in both solution''' Solution by: popomaticbubble'''import reinput_string = input('&gt; ')print()counter = {\"LETTERS\":len(re.findall(\"[a-zA-Z]\", input_string)), \"NUMBERS\":len(re.findall(\"[0-9]\", input_string))}print(counter)#奇奇怪怪 re模块，遇到再说，忽略一哈'''Solution by: MarkisLandis'''sen = input(\"\").split(\" \")alp, digit = 0, 0for item in sen: lst = [char for char in item] for j in lst: if 64 &lt; ord(j) &lt; 123: alp += 1 if j.isdigit(): digit += 1print(f\"LETTERS : {alp} \\n DIGITS : {digit}\") 14.编写一个接受句子的程序，并计算大写字母和小写字母的数量。 python2 1234567891011s = raw_input()d = {\"UPPER CASE\":0, \"LOWER CASE\":0}for c in s: if c.isupper(): d[\"UPPER CASE\"]+=1 elif c.islower(): d[\"LOWER CASE\"]+=1 else: passprint \"UPPER CASE\", d[\"UPPER CASE\"]print \"LOWER CASE\", d[\"LOWER CASE\"] python3 1234567891011121314151617181920212223242526272829303132333435363738word = input()upper,lower = 0,0for i in word: if 'a'&lt;=i and i&lt;='z' : lower+=1 if 'A'&lt;=i and i&lt;='Z': upper+=1print(\"UPPER CASE {0}\\nLOWER CASE {1}\".format(upper,lower))word = input()upper,lower = 0,0for i in word: lower+=i.islower() upper+=i.isupper()print(\"UPPER CASE {0}\\nLOWER CASE {1}\".format(upper,lower))word = input()upper = sum(1 for i in word if i.isupper()) # sum function cumulatively sum up 1's if the condition is Truelower = sum(1 for i in word if i.islower())print(\"UPPER CASE {0}\\nLOWER CASE {1}\".format(upper,lower))string = input(\"Enter the sentense\")upper = 0lower = 0for x in string: if x.isupper() == True: upper += 1 if x.islower() == True: lower += 1print(\"UPPER CASE: \", upper)print(\"LOWER CASE: \", lower) 15.编写一个程序，以给定的数字作为a的值来计算a + aa + aaa + aaaa的值。 python2 123456a = raw_input()n1 = int( \"%s\" % a )n2 = int( \"%s%s\" % (a,a) )n3 = int( \"%s%s%s\" % (a,a,a) )n4 = int( \"%s%s%s%s\" % (a,a,a,a) )print n1+n2+n3+n4 python3 字符与整形数字转换，灵活应用 12345678910111213141516171819202122232425262728a = input()total,tmp = 0,str() # initialing an integer and empty stringfor i in range(4): tmp+=a # concatenating 'a' to 'tmp' total+=int(tmp) # converting string type to integer typeprint(total)a = input()total = int(a) + int(2*a) + int(3*a) + int(4*a) # N*a=Na, for example a=\"23\", 2*a=\"2323\",3*a=\"232323\"print(total)'''Solution by: ChichiLovesDonkeys'''from functools import reducex = input('please enter a digit:')reduce(lambda x, y: int(x) + int(y), [x*i for i in range(1,5)])'''Solution by: lcastrooliveira'''def question_15(string_digit): return sum(int(string_digit * n) for n in range(1, 5))inp = input()print(question_15(inp)) 16 使用列表推导对列表中的每个奇数取平方。 该列表由逗号分隔的数字序列输入。 python3 123456789101112131415161718lst = [str(int(i)**2) for i in input().split(',') if int(i) % 2]print(\",\".join(lst))'''Solution by: shagun'''square odd nolst = input().split(',') seq = []lst = [int(i) for i in lst] for i in lst: if i%2 != 0: i = i*i seq.append(i)seq = [str(i) for i in seq] # 所有整数都将转换为字符串，以便能够应用联接操作print(\",\".join(seq)) 17.编写一个程序，该程序根据控制台输入的交易日志来计算银行帐户的净额。 事务日志格式如下所示： D 100w 200D表示存款，W表示提款。假设将以下输入提供给程序： D 300D 300w 200D 100然后，输出应为： 500 python2 12345678910111213141516import sysnetAmount = 0while True: s = raw_input() if not s: break values = s.split(\" \") operation = values[0] amount = int(values[1]) if operation==\"D\": netAmount+=amount elif operation==\"W\": netAmount-=amount else: passprint netAmount python3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091total = 0while True: s = input().split() if not s: # break if the string is empty break cm,num = map(str,s) # map if cm=='D': total+=int(num) if cm=='W': total-=int(num)print(total)'''Solution by: leonedott'''#Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。lst = []while True: x = input() if len(x)==0: break lst.append(x)balance = 0for item in lst: if 'D' in item: balance += int(item.strip('D ')) if 'W' in item: balance -= int(item.strip('W '))print(balance)'''Solution by: AlexanderSro'''#不考虑数组逻辑问题，单纯计算，这个最简单account = 0while True: action = input(\"Deposit/Whitdrow/Balance/Quit? D/W/B/Q: \").lower() if action == \"d\": deposit = input(\"How much would you like to deposit? \") account = account + int(deposit) elif action == \"w\": withdrow = input(\"How much would you like to withdrow? \") account = account - int(withdrow) elif action == \"b\": print(account) else: quit() '''Solution by: ShalomPrinz 待查'''lines = []while True: loopInput = input() if loopInput == \"done\": break else: lines.append(loopInput)lst = list(int(i[2:]) if i[0] == 'D' else -int(i[2:]) for i in lines)print(sum(lst))'''Solution by: popomaticbubble '''transactions = []while True: text = input(\"&gt; \") if text: text = text.strip('D ') text = text.replace('W ', '-') transactions.append(text) else: break transactions = (int(i) for i in transactions)balance = sum(transactions)print(f\"Balance is {balance}\")'''Solution by: ChichiLovesDonkeys'''money = 0while 1: trans = input().split(' ') if trans[0] == 'D': money = money + int(trans[1]) elif trans[0] == 'W': money = money - int(trans[1]) elif input() == '': break print(f'Your current balance is: {money}') 18.网站要求用户输入用户名和密码进行注册。 编写程序以检查用户输入的密码是否有效。 以下是检查密码的标准： [a-z]之间至少1个字母[0-9]之间至少1个数字[A-Z]之间至少1个字母[$＃@]中的至少1个字符交易密码的最小长度：6交易密码的最大长度：12您的程序应接受逗号分隔的密码序列，并将根据上述条件进行检查。 符合条件的密码将被打印，每个密码之间用逗号分隔。 python2 12345678910111213141516171819202122import re #value = []items = [x for x in raw_input().split(',')]for p in items: if len(p) &lt; 6 or len(p) &gt; 12: continue else: pass if not re.search(\"[a-z]\",p):#分组匹配功能 continue elif not re.search(\"[0-9]\",p): continue elif not re.search(\"[A-Z]\",p): continue elif not re.search(\"[$#@]\",p): continue elif re.search(\"\\s\",p): continue else: pass value.append(p)print \",\".join(value) 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 python3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100def is_low(x): # Returns True if the string has a lowercase for i in x: if 'a'&lt;=i and i&lt;='z': return True return Falsedef is_up(x): # Returns True if the string has a uppercase for i in x: if 'A'&lt;= i and i&lt;='Z': return True return Falsedef is_num(x): # Returns True if the string has a numeric digit for i in x: if '0'&lt;=i and i&lt;='9': return True return Falsedef is_other(x): # Returns True if the string has any \"$#@\" for i in x: if i=='$' or i=='#' or i=='@': return True return Falses = input().split(',')lst = []for i in s: length = len(i) if 6 &lt;= length and length &lt;= 12 and is_low(i) and is_up(i) and is_num(i) and is_other(i): #Checks if all the requirments are fulfilled lst.append(i)print(\",\".(lst))#要求合在一起，作为函数def check(x): cnt = (6&lt;=len(x) and len(x)&lt;=12) for i in x: if i.isupper():#保证至少有一个就好 cnt+=1 break for i in x: if i.islower(): cnt+=1 break for i in x: if i.isnumeric(): cnt+=1 break for i in x: if i=='@' or i=='#'or i=='$': cnt+=1 break return cnt == 5 s = input().split(',')lst = filter(check,s)print(\",\".join(lst))#使用re模块import res = input().split(',')lst = []for i in s: cnt = 0 cnt+=(6&lt;=len(i) and len(i)&lt;=12) cnt+=bool(re.search(\"[a-z]\",i)) cnt+=bool(re.search(\"[A-Z]\",i)) cnt+=bool(re.search(\"[0-9]\",i)) cnt+=bool(re.search(\"[@#$]\",i)) if cnt==5: lst.append(i)print(','.split(lst))#simple'''Solution by: pratikb0501'''import rea = input('Enter passwords: ').split(',')pass_pattern = re.compile(r\"^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[$#@]).{6,12}$\")for i in a: if pass_pattern.fullmatch(i): print(i) #0.0.0.0.0.0.0.0再说吧import redef multiple (patterns, string): for i in patterns: if not re.search(i, string): return False if 6 &lt;= len(string) &lt;= 12: return True else: return Falsex = str(input(\"Type password: \"))patterns = [r\"[a-z]\", r\"[A-Z]\", r\"[0-9]\", r\"[$|#|@]\"]print(multiple(patterns, x))#与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。#以r开头的字符，常用于正则表达式，对应着re模块。#r'input\\n' # 非转义原生字符，经处理’\\n’变成了’\\‘和’n’。也就是\\n表示的是两个字符，而不是换行。 19.您需要编写一个程序来按升序对（名称，年龄，分数）元组进行排序，其中名称是字符串，年龄和分数是数字。 元组由控制台输入。 排序标准是： 1：根据名称排序2：然后根据年龄排序3：然后按分数排序优先级是名称&gt;年龄&gt;得分。 python2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from operator import itemgetter, attrgetter #模块l = []while True: s = raw_input() if not s: break l.append(tuple(s.split(\",\")))print sorted(l, key=itemgetter(0,1,2))‘’‘operator.itemgetter函数operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号。看下面的例子a = [1,2,3] &gt;&gt;&gt; b=operator.itemgetter(1) //定义函数b，获取对象的第1个域的值&gt;&gt;&gt; b(a) 2&gt;&gt;&gt; b=operator.itemgetter(1,0) //定义函数b，获取对象的第1个域和第0个的值&gt;&gt;&gt; b(a) (2, 1)要注意，operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。sorted函数用来排序，sorted(iterable[, cmp[, key[, reverse]]])其中key的参数为一个函数或者lambda函数。所以itemgetter可以用来当key的参数a = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]根据第二个域和第三个域进行排序sorted(students, key=operator.itemgetter(1,2))’‘’#python3lst = []while True: s = input().split(',') if not s[0]: # breaks for blank input break lst.append(tuple(s))lst.sort(key= lambda x:(x[0],int(x[1]),int(x[2]))) # here key is defined by lambda and the data is sorted by element priority 0&gt;1&gt;2 in accending orderprint(lst)#关于lambda格式使用问题from operator import itemgetter, attrgetter #模块l = []while True: s = input() if not s: break l.append(tuple(s.split(\",\")))print sorted(l, key=itemgetter(0,1,2))#关于区别问题 1.lambda 函数 有一个User 实例序列，希望通过他们的user id 属性进行排序，可提供一个以User 实例作为输入并输出对应user id 值的callable 对象 class User: def __init__(self, user_id): self.user_id = user_id def __repr__(self): return 'User({})'.format(self.user_id) def sort_notcompare(): users = [User(23), User(3), User(99)] print(users) print(sorted(users, key=lambda u: u.user_id))感觉 operator attrgetter/itemgetter好一点‘’‘2.operator.attrgetter() 另外一种方式是使用operator.attrgetter() 来代替lambda 函数： &gt;&gt;&gt; from operator import attrgetter &gt;&gt;&gt; sorted(users, key=attrgetter('user_id')) [User(3), User(23), User(99)] attrgetter() 函数通常会运行的快点，并且还能同时允许多个字段进行比较。 如果User 实例还有一个first name 和last name 属性排序， &gt;&gt;&gt;by_name = sorted(users, key=attrgetter('last_name', 'first_name'))’‘’ 20.用生成器定义一个类，该生成器可以在给定范围0和n之间迭代可以被7整除的数字。 python2 python3 12345678910111213141516171819202122232425'''Solution by: ShalomPrinz'''class MyGen(): def by_seven(self, n): for i in range(0, int(n/7) + 1): yield i * 7for i in MyGen().by_seven( int(input('Please enter a number... ')) ): print(i)#一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。#yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。'''Solution by: Seawolf159'''class Divisible: def by_seven(self, n): for number in range(1,n + 1): if number % 7 == 0: yield numberdivisible = Divisible()generator = divisible.by_seven(int(input(\"Please insert a number. --&gt; \")))for number in generator: print(number) #瞎搞 21.机器人从原始点（0,0）开始在平面中移动。 机器人可以按照给定的步骤向上，下，左和右移动。 机器人运动的轨迹如下所示： 上5下3左3右2方向后的数字为步长。 请编写一个程序，以计算一系列移动和原始点之后与当前位置的距离。 如果距离是浮点数，则只需打印最接近的整数。 示例：如果给出以下元组作为程序的输入： 上5下3左3右2然后，程序的输出应为：2 python2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import mathpos = [0,0]while True: s = raw_input() if not s: break movement = s.split(\" \") #提取 0 1 direction = movement[0] steps = int(movement[1]) if direction==\"UP\": pos[0]+=steps elif direction==\"DOWN\": pos[0]-=steps elif direction==\"LEFT\": pos[1]-=steps elif direction==\"RIGHT\": pos[1]+=steps else: passprint int(round(math.sqrt(pos[1]**2+pos[0]**2)))python3x,y = 0,0while True: s = input().split() if not s: break if s[0]=='UP': x-=int(s[1]) if s[0]=='DOWN': x+=int(s[1]) if s[0]=='LEFT': y-=int(s[1]) if s[0]=='RIGHT': y+=int(s[1]) # diference x and y '''Solution by: pratikb0501'''from math import sqrtlst = []position = [0,0]while True: a = input() if not a: break lst.append(a)for i in lst: if 'UP' in i: position[0] -= int(i.strip('UP ')) #去除字符 if 'DOWN' in i: position[0] += int(i.strip('DOWN ')) if 'LEFT' in i: position[1] -= int(i.strip('LEFT ')) if 'RIGHT' in i: position[1] += int(i.strip('RIGHT '))print(round(sqrt(position[1] ** 2 + position[0] ** 2)))#还是吧输入看成列表字典好一点，去除字符提取数字感觉不怎么舒服，input（）.split() 关于类的一些小格式 22.编写程序以计算输入中单词的频率。 输出应在按字母数字排序后输出。 计算频次，还是老三样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556freq = {} # frequency of words in textline = raw_input()for word in line.split(): freq[word] = freq.get(word,0)+1 #字典dictwords = freq.keys()words.sort()for w in words: print \"%s:%d\" % (w,freq[w]) #Python 3全场最佳ss = input().split() #ss用来计算 word用来选择keyword = sorted(set(ss)) # split words are stored and sorted as a setfor i in word: print(\"{0}:{1}\".format(i,ss.count(i))) #count #split的第一个参数是分隔符。 如果省略第一个参数,默认把所有的空格、制表符、回车符当作分隔符,并过滤掉空串ss = input().split()dict = {}for i in ss: i = dict.setdefault(i,ss.count(i)) # setdefault() function takes key &amp; value to set it as dictionary.dict = sorted(dict.items()) # items() function returns both key &amp; value of dictionary as a list # and then sorted. The sort by default occurs in order of 1st -&gt; 2nd keyfor i in dict: print(\"%s:%d\"%(i[0],i[1])) ss = input().split()dict = {i:ss.count(i) for i in ss} # sets dictionary as i-&gt; split word &amp; ss.count(i) -&gt; total occurrence of i in ssdict = sorted(dict.items()) # items() function returns both key &amp; value of dictionary as a list # and then sorted. The sort by default occurs in order of 1st -&gt; 2nd keyfor i in dict: print(\"%s:%d\"%(i[0],i[1])) from collections import Counterss = input().split()ss = Counter(ss) # returns key &amp; frequency as a dictionaryss = sorted(ss.items()) # returns as a tuple listfor i in ss: print(\"%s:%d\"%(i[0],i[1])) #调用counter模块形成字典，调用数据 Solution by: AnjanKumarGfrom pprint import pprintp=input().split()pprint({i:p.count(i) for i in p}) #同 23.编写一种可以计算数字平方值的方法 123456789def square(num): return num ** 2print square(2)print square(3)python3n=int(input())print(n**2) 24.Python具有许多内置函数，如果您不知道如何使用它，则可以在线阅读文档或查找一些书籍。 但是Python对于每个内置函数都有一个内置文档函数。 请编写程序以打印一些Python内置函数文档，例如abs（），int（），raw_input（） 并添加您自己的功能的文档 python2 123456789101112131415161718192021222324252627282930print abs.__doc__print int.__doc__print raw_input.__doc__def square(num): '''Return the square value of the input number. The input number must be integer. ''' return num ** 2print square(2)print square.__doc__python3print(str.__doc__)print(sorted.__doc__)def pow(n,p): ''' param n: This is any integer number param p: This is power over n return: n to the power p = n^p ''' return n**pprint(pow(3,4))print(pow.__doc__) 25.定义一个类，该类具有一个类参数并且具有相同的实例参数。 python2 1234567891011121314151617181920212223242526272829class Person: # Define the class parameter \"name\" name = \"Person\" def __init__(self, name = None): # self.name is the instance parameter self.name = namejeffrey = Person(\"Jeffrey\")print \"%s name is %s\" % (Person.name, jeffrey.name)nico = Person()nico.name = \"Nico\"print \"%s name is %s\" % (Person.name, nico.name) #明天跑一下，不过我觉得第一个不变python3class Car: name = \"Car\" def __init__(self,name = None): self.name = namehonda=Car(\"Honda\")print(\"%s name is %s\"%(Car.name,honda.name))toyota=Car()toyota.name=\"Toyota\"print(\"%s name is %s\"%(Car.name,toyota.name)) #同#无参数返回，默认value 26.定义函数计算和 1234567def SumFunction(number1, number2): return number1 + number2print SumFunction(1,2)#2sum = lambda n1,n2 : n1 + n2 # here lambda is use to define little function as sumprint(sum(1,2)) #lambda表达式 27.定义一个可以将整数转换为字符串并在控制台中打印的函数。 python2 12345678def printValue(n): print str(n)printValue(3)conv = lambda x : str(x)n = conv(10)print(n)print(type(n)) #return type 28.定义一个函数，该函数可以接收两个字符串形式的整数并计算它们的总和，然后在控制台中打印它 123456def printValue(s1,s2): print int(s1) + int(s2)printValue(\"3\",\"4\")#3sum = lambda s1,s2 : int(s1) + int(s2)print(sum(\"10\",\"45\")) 29.定义一个函数，该函数可以接受两个字符串作为输入并将它们连接起来，然后在控制台中将其打印出来。 1234567def printValue(s1,s2): print s1 + s2printValue(\"3\",\"4\") #2sum = lambda s1,s2 : s1 + s2print(sum(\"10\",\"45\")) 30.定义一个可以接受两个字符串作为输入的函数，并在控制台中打印最大长度的字符串。如果两个字符串的长度相同，则该函数应逐行打印所有字符串。 123456789101112def printValue(s1,s2): len1 = len(s1) len2 = len(s2) if len1 &gt; len2: print s1 elif len2 &gt; len1: print s2 else: print s1 print s2printValue(\"one\",\"three\") 12345678910111213141516def printVal(s1,s2): len1 = len(s1) len2 = len(s2) if len1 &gt; len2: print(s1) elif len1 &lt; len2: print(s2) else: print(s1) print(s2)s1,s2=input().split()printVal(s1,s2) #函数的定义'''Solution by: yuan1z'''func = lambda a,b: print(max((a,b),key=len)) if len(a)!=len(b) else print(a+'\\n'+b) 31.定义一个字典，key 1-20 value square 12345678910111213def printDict(): d=dict() for i in range(1,21): #有个小问题，range数字范围1~20 d[i]=i**2 print dprintDict()def printDict(): dict={i:i**2 for i in range(1,21)} # Using comprehension method and print(dict)printDict() 32.同上，但是只输出key值 .keys 1234567def printDict(): d=dict() for i in range(1,21): d[i]=i**2 for k in d.keys(): print kprintDict() 12345def printDict(): dict = {i: i**2 for i in range(1, 21)} print(dict.keys()) # print keys of a dictionaryprintDict() 33.生成并输出列表，1-20 square 12345678910111213def printList(): li=list() for i in range(1,21): li.append(i**2) print liprintList()def printList(): lst = [i ** 2 for i in range(1, 21)] #list内部 print(lst)printList() 34.同上，不过只输出前五value 切片，笨呐 12345678910111213def printList(): li=list() for i in range(1,21): li.append(i**2) print li[:5]printList()def printList(): lst = [i ** 2 for i in range(1, 21)] for i in range(5): print(lst[i]) # print(lst[:5]) 一句就好printList() 35.同，输出后五 15:20 1234567891011121314151617181920def printList(): li=list() for i in range(1,21): li.append(i**2) print li[-5:]printList()def printList(): lst = [i ** 2 for i in range(1, 21)] for i in range(19,14,-1): print(lst[i])printList()'''Solution by: popomaticbubble'''def squares(n): squares_list = [i**2 for i in range(1,n+1)] print(squares_list[-5:])squares(20) 36.同 ，输出除前五个 5： 1234567891011121314def printList(): li=list() for i in range(1,21): li.append(i**2) print li[5:]printList()def printList(): lst = [i ** 2 for i in range(1, 21)] for i in range(5,20): print(lst[i])printList() 37.生成一个元组 1-20 square 12345678910111213141516171819202122def printTuple(): li=list() for i in range(1,21): li.append(i**2) print tuple(li)printTuple()def printTupple(): lst = [i ** 2 for i in range(1, 21)] print(tuple(lst))printTupple()'''Solution by: Seawolf159'''def square_of_numbers(): return tuple(i ** 2 for i in range(1, 21))print(square_of_numbers()) #直接转换 38.使用给定的元组（1,2,3,4,5,6,7,8,9,10），编写一个程序以在一行中打印前一半值，并在一行中打印后一半值。 12345678910111213141516171819202122232425262728293031323334353637383940tp = (1,2,3,4,5,6,7,8,9,10)tp1 = tp[:5]tp2 = tp[5:]print tp1print tp2tpl = (1,2,3,4,5,6,7,8,9,10)for i in range(0,5): print(tpl[i],end = ' ')print()for i in range(5,10): print(tpl[i],end = ' ') tpl = (1,2,3,4,5,6,7,8,9,10)lst1,lst2 = [],[]for i in range(0,5): lst1.append(tpl[i])for i in range(5,10): lst2.append(tpl[i])print(lst1)print(lst2)'''Solution by: CoffeeBrakeInc'''tup = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)lt = int(len(tup)/2)print(tup[:lt], tup[lt:])'''Solution by: AasaiAlangaram'''tp = (1,2,3,4,5,6,7,8,9,10)print('The Original Tuple:',tp)[print('Splitted List :{List}'.format(List = tp[x:x+5])) for x in range(0,len(tp),5)] #emmmm 39.编写程序以生成并打印另一个在给定元组（1,2,3,4,5,6,7,8,9,10）中其值为偶数的元组。 转换成列表 有个错误，懒得提交了12345678910111213141516tp = (1,2,3,4,5,6,7,8,9,10)li = list()for i in tp: if tp[i]%2 == 0: li.append(tp[i])tp2 = tuple(li)print tp2 #有错误 tp元组 直接用value i，网站代码错误tpl = (1,2,3,4,5,6,7,8,9,10)tpl1 = tuple(i for i in tpl if i%2 == 0)print(tpl1)---------------------------------------------------tpl = (1,2,3,4,5,6,7,8,9,10)tpl1 = tuple(filter(lambda x : x%2==0,tpl)) # Lambda function returns True if found even element. # Filter removes data for which function returns Falseprint(tpl1) ------------------------------------------------------- 40.编写一个接受字符串作为输入的程序，如果字符串为“是”或“是”或“是”，则打印“是”，否则打印“否”。 123456789101112131415161718192021222324252627s= raw_input()if s==\"yes\" or s==\"YES\" or s==\"Yes\": print \"Yes\"else: print \"No\" text = input(\"Please type something. --&gt; \")if text == \"yes\" or text == \"YES\" or text == \"Yes\": print(\"Yes\")else: print(\"No\") Solution by: AasaiAlangaram input = input('Enter string:')output = ''.join(['Yes' if input == 'yes' or input =='YES' or input =='Yes' else 'No' ])print(str(output))Solution by: Prashanth x = str(input().lower())# 直接同化，根源简化，学习一哈if x == 'yes': print('Yes')else: print('No') map与filter用法示例41.编写一个程序，该程序可以map（）创建一个列表，该列表的元素是[1,2,3,4,5,6,7,8,9,10]中的元素的平方。 123456789li = [1,2,3,4,5,6,7,8,9,10]squaredNumbers = map(lambda x: x**2, li)print squaredNumbers# No different way of code is written as the requirment is specificly mentioned in problem descriptionli = [1,2,3,4,5,6,7,8,9,10]squaredNumbers = map(lambda x: x**2, li) # returns map type object dataprint(list(squaredNumbers)) # converting the object into list 42.编写一个程序，该程序可以map（）和filter（）构成一个列表，该列表的元素为[1,2,3,4,5,6,7,8,9,10]中的偶数平方。 12345678910111213li = [1,2,3,4,5,6,7,8,9,10]evenNumbers = map(lambda x: x**2, filter(lambda x: x%2==0, li))print evenNumbersdef even(x): #2333，还是思维问题 return x%2==0def squer(x): return x*xli = [1,2,3,4,5,6,7,8,9,10]li = map(squer,filter(even,li)) # first filters number by even number and the apply map() on the resultant elementsprint(list(li)) 43.编写一个程序，该程序可以使用filter（）创建一个列表，该列表的元素为1到20之间的偶数（均包括在内。 1234567evenNumbers = filter(lambda x: x%2==0, range(1,21))print evenNumbersdef even(x): return x%2==0evenNumbers = filter(even, range(1,21))print(list(evenNumbers)) 44.编写一个程序，该程序可以map（）创建一个列表，该列表的元素为1到20之间的数字平方（均包括在内）。 12345678squaredNumbers = map(lambda x: x**2, range(1,21))print squaredNumbersdef sqr(x): return x*xsquaredNumbers = list(map(sqr, range(1,21)))print (squaredNumbers) 45.定义一个名为American的类，该类具有一个称为printNationality的静态方法。 静态方法 么得意义呀12345678910111213141516171819class American(object): @staticmethod def printNationality(): print \"America\"anAmerican = American()anAmerican.printNationality()American.printNationality()class American(): @staticmethod def printNationality(): print(\"I am American\")american = American()american.printNationality() # this will not run if @staticmethod does not decorates the function. # Because the class has no instance.American.printNationality() # this will run even though the @staticmethod # does not decorate printNationality() 46.定义一个名为American的类及其子类NewYorker。 python 1234567891011121314151617181920212223class American(object): passclass NewYorker(American): passanAmerican = American()aNewYorker = NewYorker()print anAmericanprint aNewYorkerclass American(): passclass NewYorker(American): passamerican = American()newyorker = NewYorker()print(american)print(newyorker) 在 Python3.x 的时候 pass 可以写或不写。空的 python2.x： 123def function(): # 空函数在Python2.x版本中pass是必须的 pass python3.x 123def function(): # 在Python3.x的时候pass可以写或不写 pass 47.定义一个名为Circle的类，该类可以由半径构造。 Circle类具有一种可以计算面积的方法。 1234567891011121314151617181920class Circle(object): def __init__(self, r): self.radius = r def area(self): return self.radius**2*3.14aCircle = Circle(2) #参数携带print aCircle.area()class Circle(): def __init__(self,r): self.radius = r def area(self): return 3.1416*(self.radius**2)circle = Circle(5)print(circle.area()) 48.定义一个名为Rectangle的类，该类可以通过长度和宽度来构造。 Rectangle类具有可以计算面积的方法。 12345678910111213141516171819202122class Rectangle(object): #多参数 def __init__(self, l, w): self.length = l self.width = w def area(self): return self.length*self.widthaRectangle = Rectangle(2,10)print aRectangle.area()class Rectangle(): def __init__(self,l,w): self.length = l self.width = w def area(self): return self.length*self.widthrect = Rectangle(2,4)print(rect.area()) 49.定义一个名为Shape的类及其子类Square。 Square类具有一个init函数，该函数以长度作为参数。 这两个类都有一个Area函数，该函数可以打印Shape的区域默认为0的形状的区域。 12345678910111213141516171819202122232425262728293031323334353637class Shape(object): def __init__(self): pass def area(self): return 0class Square(Shape): def __init__(self, l): Shape.__init__(self) self.length = l def area(self): return self.length*self.lengthaSquare= Square(3)print aSquare.area()class Shape(): def __init__(self): pass def area(self): return 0class Square(Shape): def __init__(self,length = 0): Shape.__init__(self) self.length = length def area(self): return self.length*self.lengthAsqr = Square(5)print(Asqr.area()) # prints 25 as given argumentprint(Square().area()) # prints zero as default area 设置默认值 50.请引发RuntimeError异常。 1raise RuntimeError('something wrong') implimantation of object oriented programming ～～～`～～～～～～～～～～～～～～ try / except51.编写一个函数以计算5/0并使用try / except捕获异常。 123456789101112131415161718192021def throws(): return 5/0try: throws()except ZeroDivisionError: print \"division by zero!\"except Exception, err: print 'Caught an exception'finally: print 'In finally block for cleanup' python3def divide(): return 5/0try: divide()except ZeroDivisionError as ze: print(\"Why on earth you are dividing a number by ZERO!!\")except: print(\"Any other exception\") 52.定义一个自定义异常类，该类将字符串消息作为属性。 123456789101112131415161718192021222324252627282930313233343536373839class MyError(Exception): \"\"\"My own exception class Attributes: msg -- explanation of the error \"\"\" def __init__(self, msg): self.msg = msgerror = MyError(\"something wrong\")python3class CustomException(Exception): \"\"\"Exception raised for custom purpose Attributes: message -- explanation of the error \"\"\" def __init__(self, message): self.message = messagenum = int(input())try: if num &lt; 10: raise CustomException(\"Input is less than 10\") elif num &gt; 10: raise CustomException(\"Input is grater than 10\")except CustomException as ce: print(\"The error raised: \" + ce.message) try: xxexcept: raise CustomException(\"自定义报错。。。。。。\") 53.假设我们有一些“ username@companyname.com”格式的电子邮件地址，请编写程序以打印给定电子邮件地址的用户名。 用户名和公司名都仅由字母组成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import reemailAddress = raw_input()pat2 = \"(\\w+)@((\\w+\\.)+(com))\"r2 = re.match(pat2,emailAddress)print r2.group(1) #???????????python3email = \"john@google.com\"email = email.split('@')print(email[0])#re 模块import reemail = \"john@google.com elise@python.com\"pattern = \"(\\w+)@\\w+.com\" #括号ans = re.findall(pattern,email)print(ans)关于re #!/usr/bin/python# -*- coding: UTF-8 -*- import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为：findall(string[, pos[, endpos]])参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。 # -*- coding:UTF8 -*- import re pattern = re.compile(r'\\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2)['123', '456']['88', '12'] #0,10 54.假设我们有一些电子邮件格式为“ username@companyname.com”，请编写程序以打印给定电子邮件地址的公司名称。 用户名和公司名都仅由字母组成。 123456789101112import reemailAddress = raw_input()pat2 = \"(\\w+)@(\\w+)\\.(com)\"r2 = re.match(pat2,emailAddress)print r2.group(2)import reemail = \"john@google.com elise@python.com\"pattern = \"\\w+@(\\w+).com\"ans = re.findall(pattern,email)print(ans) 55.编写一个程序，该程序接受由空格分隔的单词序列作为输入，以仅打印由数字组成的单词。 123456789101112131415161718192021import res = raw_input()print re.findall(\"\\d+\",s)import reemail = input()pattern = \"\\d+\"ans = re.findall(pattern,email)print(ans)#我的解法，还是死脑筋呀email = input().split()ans = []for word in email: if word.isdigit(): ans.append(word)print(ans)email = input().split()ans = [word for word in email if word.isdigit()] # using list comprehension methodprint(ans) 56.打印一个unicode字符串“ hello world”。 123unicodeString = u\"hello world!\"print unicodeString ASCII与unicode57.编写程序以读取ASCII字符串并将其转换为utf-8编码的unicode字符串。 1234567s = raw_input()u = unicode( s ,\"utf-8\")print us = input()u = s.encode('utf-8')print(u) 中文字符58.编写特殊注释以指示Python源代码文件为unicode。 1# -*- coding: utf-8 -*- 59.编写一个程序，通过控制台（n&gt; 0）输入给定的n输入来计算1/2 + 2/3 + 3/4 + … + n / n + 1。 12345678910111213141516171819202122232425262728293031323334n=int(raw_input())sum=0.0for i in range(1,n+1): sum += float(float(i)/(i+1))print sumn = int(input())sum = 0for i in range(1, n+1): sum+= i/(i+1)print(round(sum, 2))# round() 方法返回浮点数x的四舍五入值。语法以下是 round() 方法的语法:round( x [, n] )参数 x -- 数值表达式。 n -- 数值表达式，表示从小数点位数。'''Solution by: lcastrooliveira'''def question_59(n): print(round(sum(map(lambda x: x/(x+1), range(1, n+1))), 2)) 我的解法def sum(n): i=0 while 1: i+=float(n/(n+1)) n=n-1 if n&lt;=0: break return iprint(sum(int(input()))) 60.编写程序进行计算： 当n&gt; 0时f（n）= f（n-1）+100并且f（0）= 0通过控制台输入n（n&gt; 0）。 1234567891011121314151617181920212223def f(n): if n==0: return 0 else: return f(n-1)+100 #常用n=int(raw_input())print f(n)def f(n): if n == 0: return 0 return f(n-1) + 100n = int(input())print(f(n))'''Solution by: NikolayEm'''n = int(input())f = lambda x: f(x-1)+100 if x &gt; 0 else 0print(f(n)) #lambda表达式 61.斐波那契数列是根据以下公式计算的： 如果n = 0，则f（n）= 0如果n = 1，则f（n）= 1如果n&gt; 1，则f（n）= f（n-1）+ f（n-2）请编写一个程序，以控制台输入给定的n输入来计算f（n）的值。 12345678910111213def f(n): if n == 0: return 0 elif n == 1: return 1 else: return f(n-1)+f(n-2)n=int(raw_input())print f(n)def f(n): if n &lt; 2: return n return f(n-1) + f(n-2)n = int(input())print(f(n)) 1234567'''Solution by: NikolayEm'''#一图流...n = int(input())f = lambda x: 0 if x == 0 else 1 if x == 1 else f(x-1)+f(x-2)print(','.join([str(f(x)) for x in range(0, n+1)]))#lambda 用到再说吧 62.斐波那契数列是根据以下公式计算的： 如果n = 0，则f（n）= 0如果n = 1，则f（n）= 1如果n&gt; 1，则f（n）= f（n-1）+ f（n-2）请编写一个程序，以控制台输入给定的n输入来计算f（n）的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def f(n): if n == 0: return 0 elif n == 1: return 1 else: return f(n-1)+f(n-2)n=int(raw_input())values = [str(f(x)) for x in range(0, n+1)]print \",\".join(values)#奇奇怪怪def f(n): if n &lt; 2: fibo[n] = n return fibo[n] fibo[n] = f(n-1) + f(n-2) return fibo[n]n = int(input())fibo = [0]*(n+1) # initialize a list of size (n+1)f(n) # call once and it will set value to fibo[0-n]fibo = [str(i) for i in fibo] # converting integer data to string typeans = \",\".join(fibo) # joining all string element of fibo with ',' characterprint(ans)..................................def fibo(n): if n &lt; 2: return n return fibo(n-1)+fibo(n-2)def print_fiblist(n): fib_list = [(str(fibo(i))) for i in range(0, n+1)] return print(\",\".join(fib_list))n = int(input())print_fiblist(n)..............................def question_62(n): if n == 0: return [0] if n == 1: return [0, 1] sequence = [0, 1] a, b = 0, 1 for x in range(2, n+1): c = a + b sequence.append(c) a = b b = c return sequenceprint(question_62(10)) 63.当控制台输入n时，请使用生成器编写一个程序，以逗号分隔的形式打印0到n之间的偶数。 12345678910111213def EvenGenerator(n): i=0 while i&lt;=n: if i%2==0: yield i i+=1n=int(raw_input())values = []for i in EvenGenerator(n): values.append(str(i))print \",\".join(values)#复杂，直接遍历感觉好一点呀 123456n = int(input())for i in range(0, n+1, 2): #好一点，我想着判断%，好处是不用else了，elif if i &lt; n - 1: print(i, end = ',' ) else: print(i) 64.当控制台输入n时，请使用生成器编写一个程序，以逗号分隔的形式打印可以在0和n之间被5和7整除的数字。 1234567891011121314151617def NumGenerator(n): for i in range(n+1): if i%5==0 and i%7==0: yield in=int(raw_input())values = []for i in NumGenerator(n): values.append(str(i))print \",\".join(values)def generate(n): for i in range(n+1): if i % 35 == 0: # 5*7 = 35, if a number is divisible by a &amp; b then it is also divisible by a*b yield in = int(input())resp = [str(i) for i in generate(n)]print(\",\".join(resp)) assert65.请编写assert语句以验证列表[2,4,6,8]中的每个数字都是偶数。 1234567li = [2,4,6,8]for i in li: assert i%2==0 data = [2,4,5,6]for i in data: assert i%2 == 0, \"{} is not an even number\".format(i) Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。 断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。 eval函数66.请编写一个从控制台接受基本数学表达式的程序，并打印评估结果。 123456expression = raw_input()print eval(expression)#eval() 函数用来执行一个字符串表达式，并返回表达式的值。expression = input()ans = eval(expression)print(ans) 67.请编写一个二进制binary搜索功能，该功能可以搜索已排序列表中的项目。 该函数应返回列表中要搜索的元素的索引。 我肯定直接遍历了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#python2import mathdef bin_search(li, element): bottom = 0 top = len(li)-1 index = -1 while top&gt;=bottom and index==-1: mid = int(math.floor((top+bottom)/2.0)) if li[mid]==element: index = mid elif li[mid]&gt;element: top = mid-1 else: bottom = mid+1 return indexli=[2,5,7,9,11,17,222]print bin_search(li,11)print bin_search(li,12)def binary_search(lst, item): low = 0 high = len(lst) - 1 while low &lt;= high: mid = round((low + high) / 2) #四舍五入 if lst[mid] == item: return mid elif lst[mid] &gt; item: high = mid - 1 else: low = mid + 1 return None lst = [1,3,5,7,]print(binary_search(lst, 9)) #二分法def binary_search_Ascending(array, target): lower = 0 upper = len(array) print('Array Length:',upper) while lower &lt; upper: x = (lower + upper) // 2 print('Middle Value:',x) value = array[x] if target == value: return x elif target &gt; value: lower = x elif target &lt; value: upper = xArray = [1,5,8,10,12,13,55,66,73,78,82,85,88,99]print('The Value Found at Index:',binary_search_Ascending(Array, 82))～～～～～～～`～～～～～～～～～～～～～～～idx = 0def bs(num,num_list): global idx if (len(num_list) == 1): if num_list[0] == num: return idx else: return \"No exit in the list\" elif num in num_list[:len(num_list)//2]: return bs(num,num_list[:len(num_list)//2]) else: idx += len(num_list)//2 return bs(num,num_list[len(num_list)//2:])print(bs(66,[1,5,8,10,12,13,55,66,73,78,82,85,88,99,100])) 68.请使用Python模块生成一个随机浮点，其值在10到100之间。 uniform() 方法将随机生成下一个实数，它在 [x, y] 范围内。 123456import randomprint random.random()*100import randomrand_num = random.uniform(10,100)print(rand_num) 69.请使用Python模块生成一个随机浮点，其值在5到95之间。 123456import randomprint random.random()*100-5import randomrand_num = random.uniform(5,95)print(rand_num) random choice70.使用random.choice（）从列表中随机元素。 1234567li = [2,4,6,8]import randomprint random.choice([i for i in range(11) if i%2==0])import randomresp = [i for i in range(0,11,2)]print(random.choice(resp)) 71.请编写一个程序以输出一个随机数，使用随机模块和列表推导，该随机数可被5和7整除，介于10和150之间（包括10和150）。 1234567import randomprint random.choice([i for i in range(10,151) if i%5==0 and i%7==0])import randomresp = [i for i in range(10,151) if i % 35 == 0 ]print(random.choice(resp)) 72.请编写程序以生成包含5个随机数（介于100和200之间）的列表。 123456789101112131415161718import randomprint random.sample(range(100,201), 5)import randomresp = random.sample(range(100,201),5)print(resp)sample(序列a，n)功能：从序列a中随机抽取n个元素，并将n个元素生以list形式返回。例： from random import randint, sample date = [randint(10,20) for _ in range(10)] c = sample(date, 5) print(c) # 输出：[12, 17, 10, 12, 17] 73.请编写一个程序以随机生成一个列表，该列表包含100至200之间（含100和200）的5个偶数。 123456import randomprint random.sample([i for i in range(100,201) if i%2==0], 5)import randomresp = random.sample(range(100,201,2),5)print(resp) 74.请编写一个程序以随机生成一个包含5个数字的列表，这些数字可被5和7整除（介于1和1000之间）。 1234567import randomprint random.sample([i for i in range(1,1001) if i%5==0 and i%7==0], 5)import randomlst = [i for i in range(1,1001) if i%35 == 0]resp = random.sample(lst,5)print(resp) 75.请编写一个程序以随机打印7到15之间的一个整数。\\ 12import randomprint random.randrange(7,16) 76.请编写一个程序来压缩和解压缩字符串“ hello world！hello world！hello world！hello world！”。 python2 1234567891011121314import zlibs = 'hello world!hello world!hello world!hello world!'t = zlib.compress(s)print tprint zlib.decompress(t)'''Solution by: anas1434 '''s = 'hello world!hello world!hello world!hello world!'# In Python 3 zlib.compress() accepts only DataType &lt;bytes&gt;y = bytes(s, 'utf-8')x = zlib.compress(y)print(x)print(zlib.decompress(x)) 程序运行时间77.请编写程序以打印执行“ 1 + 1”的运行时间100次。 123456789101112from timeit import Timert = Timer(\"for i in range(100):1+1\")print t.timeit()import timebefore = time.time()for i in range(100): x = 1 + 1after = time.time()execution_time = after - beforeprint(execution_time) shuffle随机洗牌78.请编写一个程序以随机播放并打印列表[3,6,7,8]。 python2 12345678910111213141516from random import shuffleli = [3,6,7,8]shuffle(li)print liimport randomlst = [3,6,7,8]random.shuffle(lst)print(lst)import random# shuffle with a chosen seedlst = [3,6,7,8]seed = 7random.Random(seed).shuffle(lst)print(lst) 79.请编写一个程序以生成所有句子，其中主语位于[“ I”，“ You”]中，动词位于[“ Play”，“ Love”]中，而宾语位于[“ Hockey”，“ Football”]中。 12345678910111213141516171819202122232425262728subjects=[\"I\", \"You\"]verbs=[\"Play\", \"Love\"]objects=[\"Hockey\",\"Football\"]for i in range(len(subjects)): for j in range(len(verbs)): for k in range(len(objects)): sentence = \"%s %s %s.\" % (subjects[i], verbs[j], objects[k]) print sentence subjects=[\"I\", \"You\"]verbs=[\"Play\", \"Love\"]objects=[\"Hockey\",\"Football\"]for sub in subjects: for verb in verbs: for obj in objects: print(\"{} {} {}\".format(sub,verb,obj)) '''Solution by: popomaticbubble'''import itertoolssubject = [\"I\", \"You\"]verb = [\"Play\", \"Love\"]objects = [\"Hockey\",\"Football\"]sentence = [subject, verb, objects]n = list(itertools.product(*sentence))for i in n: print(i) 3.1 product 迭代工具product相当于 嵌套的for 123456789101112131415161718192021222324252627282930‘’‘排列组合迭代器 product 嵌套的for’‘’from itertools import productfor i,j in product([1,2,3],[4,5]):print(i,j） product 用于求多个可迭代对象的笛卡尔积(Cartesian Product)，它跟嵌套的 for 循环等价.即:product(A, B) 和 ((x,y) for x in A for y in B)的效果是一样的。使用形式如下：itertools.product(*iterables, repeat=1)iterables 是可迭代对象, repeat指定 iterable 重复几次,即:product(A,repeat=3)等价于product(A,A,A) '''Solution by: lcastrooliveira'''from itertools import productdef question_79(): subject = [\"I\", \"You\"] verb = [\"Play\", \"Love\"] #product object = [\"Hockey\", \"Football\"] prod = [p for p in product(range(2), repeat=3)] #product 排列组合三次 for combination in prod: print(f'{subject[combination[0]]} {verb[combination[1]]} {object[combination[2]]}') 80.请删除[5,6,77,45,22,12,24]中的偶数后编写程序以打印列表。 12345678910111213141516171819202122My solutionlst=[5,6,77,45,22,12,24]ls=[]for i in lst: if i%2!=0: ls.append(i)print(ls)li = [5,6,77,45,22,12,24] # 列表内部运算li = [x for x in li if x%2!=0]print lidef isEven(n): return n%2!=0li = [5,6,77,45,22,12,24]lst = list(filter(isEven,li)) #filter操作print(lst)li = [5,6,77,45,22,12,24]lst = list(filter(lambda n:n%2!=0,li))print(lst) 81.通过使用列表理解，请编写一个程序以删除[12,24,35,70,88,120,155]中被5和7整除的数字，然后打印列表。 没啥不同 1234567li = [12,24,35,70,88,120,155]li = [x for x in li if x%5!=0 and x%7!=0]print lili = [12,24,35,70,88,120,155]li = [x for x in li if x % 35!=0]print(li) 82.通过使用列表理解，请编写一个程序来删除[12,24,35,70,88,120,155]中的第0、2、4、6个数字，然后打印列表。 我的常用解法 123456lst=[12,24,35,70,88,120,155]for i in range(0,6,2): lst.remove(lst[i])print(lst) 1234567891011121314li = [12,24,35,70,88,120,155]li = [x for (i,x) in enumerate(li) if i%2 != 0 and i &lt;= 6]print lili = [12,24,35,70,88,120,155]li = [li[i] for i in range(len(li)) if i%2 != 0 and i &lt;= 6]print(li)'''Solution by: popomaticbubble'''orig_lst = [12,24,35,70,88,120,155]indices = [0, 2, 4, 6]new_list = [i for (j, i) in enumerate(orig_lst) if j not in indices]# enumerateprint(new_list) 83.通过使用列表理解，请编写一个程序来删除[12,24,35,70,88,120,155]中的第2至4个数字，然后打印列表。 12345678910111213141516171819202122232425lst=[12,24,35,70,88,120,155]for i in range(1,4): lst.remove(lst[1])print(lst) #考虑数组删除之后变序问题li = [12,24,35,70,88,120,155]li = [x for (i,x) in enumerate(li) if i&lt;3 or 4&lt;i]print li#to be writtenli = [12,24,35,70,88,120,155]li = [li[i] for i in range(len(li)) if i &lt; 3 or i &gt; 4]print(li)'''Solution by: popomaticbubble'''orig_list = [12,24,35,70,88,120,155]new_list = [i for (j, i) in enumerate(orig_list) if j not in range(1,4)]print(new_list) array 关于数组84.通过使用列表理解，请编写一个程序，生成一个3 5 8 3D数组，每个元素为0。 12array = [[ [0 for col in range(8)] for col in range(5)] for row in range(3)]print array 85.通过使用列表理解，请编写一个程序以删除[12,24,35,70,88,120,155]中的第0、4、5个数字，然后打印列表。 12345678910111213li = [12,24,35,70,88,120,155]li = [x for (i,x) in enumerate(li) if i not in (0,4,5)]print lili = [12,24,35,70,88,120,155]li = [li[i] for i in range(len(li)) if i not in (0,4,5)]print(li)'''Solution by: pratikb0501'''li = [12, 24, 35, 70, 88, 120, 155]print(list(j for i, j in enumerate(li) if i != 0 and i != 4 and i != 5))#输出语句计算 86.通过使用列表理解，请在删除[12,24,35,24,88,120,155]中的值24之后编写程序以打印列表。remove 123li = [12,24,35,24,88,120,155]li = [x for x in li if x!=24]print li 123li = [12,24,35,24,88,120,155]li.remove(24) # this will remove only the first occurrence of 24print(li) 87.用两个给定的列表[1,3,6,78,35,55]和[12,24,35,24,88,120,155]，编写一个程序来制作一个列表，其元素是上述给定列表的交集。 123456789101112set1=set([1,3,6,78,35,55])set2=set([12,24,35,24,88,120,155])set1 &amp;= set2 # &amp;li=list(set1)print li#多种用法list1 = [1,3,6,78,35,55]list2 = [12,24,35,24,88,120,155]set1= set(list1)set2= set(list2)intersection = set1 &amp; set2print(intersection) 123456list1 = [1,3,6,78,35,55]list2 = [12,24,35,24,88,120,155]set1= set(list1)set2= set(list2)intersection = set.intersection(set1,set2)print(intersection) 88.使用给定的列表[12,24,35,24,88,120,155,88,120,155]，编写一个程序，在删除所有保留原始顺序的重复值之后，打印此列表。（可以直接set的其实，不过无序了，这主人有点笨） 1234567891011def removeDuplicate( li ): newli=[] seen = set() for item in li: if item not in seen: seen.add( item ) #add() 方法用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作语法 newli.append(item) return newlili=[12,24,35,24,88,120,155,88,120,155]print removeDuplicate(li) 123456li = [12,24,35,24,88,120,155,88,120,155]for i in li: if li.count(i) &gt; 1:#可以 li.remove(i)print(li) 123456789def removeDuplicate( li ): seen = {} # dictionary for item in li: if item not in seen: seen[item] = True yield itemli = [12, 24, 35, 24, 88, 120, 155, 88, 120, 155]ans = list(removeDuplicate(li))print(ans) 89.定义一个类Person及其两个子类：Male和Female。 所有类都有一个方法“ getGender”，可以为“男”类打印“男”，为“女”打印“女”。 1234567891011121314151617181920212223242526272829303132333435363738class Person(object): def getGender( self ): return \"Unknown\"class Male( Person ): def getGender( self ): return \"Male\"class Female( Person ): def getGender( self ): return \"Female\"aMale = Male()aFemale= Female()print aMale.getGender()print aFemale.getGender()'''Solution by: popomaticbubble'''class Person(object): #参数传递问题 def __init__(self): self.gender = \"unknown\" def getGender(self): print(self.gender)class Male(Person): def __init__(self): self.gender = \"Male\"class Female(Person): def __init__(self): self.gender = \"Female\"sharon = Female()doug = Male()sharon.getGender()doug.getGender() 90.请编写一个程序，该程序对控制台输入的字符串中的每个字符的数量进行计数和打印。 1234567891011121314151617181920212223242526272829dic = {}s=raw_input()for s in s: dic[s] = dic.get(s,0)+1print '\\n'.join(['%s,%s' % (k, v) for k, v in dic.items()])#python3import strings = input()for letter in string.ascii_lowercase: cnt = s.count(letter) if cnt &gt; 0: print(\"{},{}\".format(letter,cnt)) s = input()for letter in range(ord('a'),ord('z')+1): # ord() gets the ascii value of a char letter = chr(letter) # chr() gets the char of an ascii value cnt = s.count(letter) if cnt &gt; 0: print(\"{},{}\".format(letter,cnt)) #都为了防止重复，其实可以借用set，我的解法如下 s = input()for letter in range(list(set(s))): cnt = s.count(letter) if cnt &gt; 0: print(\"{},{}\".format(letter,cnt)) 91.请编写一个程序，该程序从控制台接受一个字符串，然后以相反的顺序打印它。…太简单了 12345678s=raw_input()s = s[::-1]print s #切片s = input()s = ''.join(reversed(s))#函数print(s) 92.请编写一个程序，该程序从控制台接受一个字符串，并打印具有偶数索引的字符. 1234567891011121314s=raw_input()s = s[::2]print ss = \"H1e2l3l4o5w6o7r8l9d\"s = [ s[i] for i in range(len(s)) if i%2 ==0 ]print(''.join(s))s = \"H1e2l3l4o5w6o7r8l9d\"ns =''for i in range(len(s)): if i % 2 == 0: ns+=s[i]print(ns) 排列组合问题 itertools93.请编写一个程序，打印所有[1,2,3]的排列 12import itertoolsprint list(itertools.permutations([1,2,3])) 94.编写一个程序解决经典的中国古代难题：我们在农场的鸡和兔中数出35头和94腿。 我们有几只兔子和几只鸡？ 123456789101112def solve(numheads,numlegs): ns='No solutions!' for i in range(numheads+1): j=numheads-i if 2*i+4*j==numlegs: return i,j return ns,nsnumheads=35numlegs=94solutions=solve(numheads,numlegs)print solutions 95.根据您在大学运动日的参与者得分表，您需要找到亚军得分。 您得到分数。 将它们存储在列表中，并找到第二名的分数。 1234567891011121314151617181920212223242526272829303132333435363738394041n = int(input())arr = map(int, input().split())arr = list(set(arr))arr.sort()print(arr[-2]) #消除同分并且sort'''Solution by: mishrasunny-coder'''num = int(input(\"Enter num: \"))L = []# 只是读取输入数组方式不同，判断类似while True: L.append(num) num = int(input(\"Enter another: \")) if num == 0: breakL1 = list(set(L[:]))L2 = sorted(L1)print(L2)print(f'The runner up is {L2[-2]}')#去掉大的，第二变成最大，一般般，不如直接remove最大的233'''Solution by: KailashS3 '''num = int(input())scores = list(map(int, input().split(' ')))winner = max(scores)lst = []if len(scores) != num: print('length of score is greater than input given')else: for score in scores: if winner &gt; score: lst.append(score)runnerup = max(lst)print(runnerup) 96.给您一个字符串S和宽度W。您的任务是将字符串包装成一段宽度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import textwrap#导入函数，而没过def wrap(string, max_width): string = textwrap.wrap(string,max_width) string = \"\\n\".join(string) return stringif __name__ == '__main__': string, max_width = input(), int(input()) result = wrap(string, max_width) print(result) '''Solution by: mishrasunny-coder'''import textwrapstring = input()width = int(input())print(textwrap.fill(string,width))'''solution by : Prashanth'''from textwrap import wrapx = str(input(': '))w = int(input())z = list(wrap(x, w))for i in z: print(i)#用个常规的string = list(input().split())l=[]width = int(input())while true: print(string[:width],end='') string.remove(string[:width]) if len(string)&lt;=3: print(string) break#我的常规解法string = input() #注意split用法，小心错误分割string=list(string)l=[]width = int(input())while True: print(''.join(string[:width]),end=' \\n') #去除列表，进行输出 注意一下seq for i in string[:width]: string.remove(i) if len(string)&lt;=3: print(''.join((string))) break 97.给您一个整数N。您的任务是打印一个大小为N的字母rangoli。（Rangoli是一种基于图案创建的印度民间艺术形式。）整合一下 1234567891011121314151617181920212223import stringdef print_rangoli(size): n = size alph = string.ascii_lowercase width = 4 * n - 3 ans = [] for i in range(n): left = '-'.join(alph[n - i - 1:n]) mid = left[-1:0:-1] + left final = mid.center(width, '-') ans.append(final) if len(ans) &gt; 1: for i in ans[n - 2::-1]: ans.append(i) ans = '\\n'.join(ans) print(ans)if __name__ == '__main__': n = int(input()) print_rangoli(n) 查询时间98.您有个约会。 您的任务是查找当天的星期几。 123456import calendarmonth, day, year = map(int, input().split())dayId = calendar.weekday(year, month, day)print(calendar.day_name[dayId].lower()) 99.给定2组整数M和N，按升序打印它们的对称差。 术语“对称差”表示存在于M或N中但不存在于两者中的那些值。 1234567891011if __name__ == '__main__': n = int(input()) set1 = set(map(int,input().split())) m = int(input()) set2 = set(map(int, input().split())) ans = list(set1 ^ set2) ans.sort() for i in ans: print(i) python 集合运算12345678910111213141516171819202122232425262728293031323334# 在对集合做运算时，不会影响原来的集合，而是返回一个运算结果# 创建两个集合s = {1,2,3,4,5}s2 = {3,4,5,6,7}# &amp; 交集运算result = s &amp; s2 # {3, 4, 5}# | 并集运算result = s | s2 # {1,2,3,4,5,6,7}# - 差集result = s - s2 # {1, 2}# ^ 异或集 获取只在一个集合中出现的元素result = s ^ s2 # {1, 2, 6, 7}# &lt;= 检查一个集合是否是另一个集合的子集# 如果a集合中的元素全部都在b集合中出现，那么a集合就是b集合的子集，b集合是a集合超集a = {1,2,3}b = {1,2,3,4,5}result = a &lt;= b # Trueresult = {1,2,3} &lt;= {1,2,3} # Trueresult = {1,2,3,4,5} &lt;= {1,2,3} # False# &lt; 检查一个集合是否是另一个集合的真子集# 如果超集b中含有子集a中所有元素，并且b中还有a中没有的元素，则b就是a的真超集，a是b的真子集result = {1,2,3} &lt; {1,2,3} # Falseresult = {1,2,3} &lt; {1,2,3,4,5} # True# &gt;= 检查一个集合是否是另一个的超集# &gt; 检查一个集合是否是另一个的真超集print('result =',result)","categories":[],"tags":[]},{"title":"dynamixelros","slug":"dynamixelros/dynamixelros","date":"2020-07-28T01:37:25.000Z","updated":"2020-08-07T11:38:56.049Z","comments":true,"path":"2020/07/28/dynamixelros/dynamixelros/","permalink":"http://xiaomuhou.github.io/2020/07/28/dynamixelros/dynamixelros/","excerpt":"Dynamixel_workbench目的：解析一下workbench包以及dynamixel_motor包，复习语法以及ros基础","text":"Dynamixel_workbench目的：解析一下workbench包以及dynamixel_motor包，复习语法以及ros基础 dynamixel_workbench 0.dynamixel_workbench package.xml workbench 用于ros开发 1.controllers 查询电机属性 2.operators 控制电机 3.toolbox 库 dynamixel_motor(python)该软件包包含一个可配置的节点，服务和一个生成器脚本，用于启动，停止和重新启动一个或多个控制器插件。 为常见的Dynamixel电机接头定义了可重复使用的控制器类型。 可以为每个关节设置速度和扭矩。 此python软件包可由更特定的机器人控制器使用，并且所有可配置的参数都可以通过yaml文件加载。 1.controllers node controller_manager: controller_spawner: 2.driver 该软件包为Robotis Dynamixel伺服器提供了低电平IO。 完全支持AX-12，AX-18，RX-24，RX-28，MX-28，RX-64，EX-106型号并经过测试。 定义了特定于硬件的常量，用于从Dynamixel伺服器读取信息或向其写入信息。 大多数ROS用户都不会直接使用此低级软件包。 更高级别的dynamixel_controllers和特定的机器人关节控制器使用此程序包。 3.motor 4.msgs 整个dynamixel_motor堆栈使用的常见消息。 5.tutorials dynamixel_motor堆栈的示例配置和启动文件。","categories":[],"tags":[]},{"title":"logic_symbol","slug":"logic-symbol/logic-symbol","date":"2020-07-27T12:17:42.000Z","updated":"2020-07-27T13:02:41.721Z","comments":true,"path":"2020/07/27/logic-symbol/logic-symbol/","permalink":"http://xiaomuhou.github.io/2020/07/27/logic-symbol/logic-symbol/","excerpt":"逻辑符号这篇博文主要为了总结一下逻辑运算符号（拯救混乱记忆，雾） (下一篇是题目总结顺便复习)","text":"逻辑符号这篇博文主要为了总结一下逻辑运算符号（拯救混乱记忆，雾） (下一篇是题目总结顺便复习) 1.逻辑结构 与运算： 与(&amp;&amp;)：逻辑规则是两真才真。与and等同。 或运算： 或(||)：逻辑规则是只有一个为真就为真。与or等同。 异或： 异或(^)：逻辑规则是两个不同就为真。 非运算符： 非(！)：逻辑规则是反转操作数的含义。与not等同。 电路中的符合逻辑与非： 输入只要有0，输出为1.输入全1，输出才0 或非：输入只要有1，输出为0，输入全为0，输出才1 与或非：复合运算 电路中还存在异或与同或 异或：相异则为1 同或：相同则为1 关于逻辑电路门，以后再说吧233","categories":[{"name":"logic","slug":"logic","permalink":"http://xiaomuhou.github.io/categories/logic/"}],"tags":[]},{"title":"pybasic","slug":"pybasic/pybasic","date":"2020-07-27T11:03:51.000Z","updated":"2020-09-26T13:22:04.898Z","comments":true,"path":"2020/07/27/pybasic/pybasic/","permalink":"http://xiaomuhou.github.io/2020/07/27/pybasic/pybasic/","excerpt":"基础方便查看，资料来源{https://github.com/fengdu78/Data-Science-Notes/blob/master/1.python-basic/Python_Basic.ipynb} 2020.09.26 添加了python新内容，包括之后的进阶记录会在这里更新。","text":"基础方便查看，资料来源{https://github.com/fengdu78/Data-Science-Notes/blob/master/1.python-basic/Python_Basic.ipynb} 2020.09.26 添加了python新内容，包括之后的进阶记录会在这里更新。 1.数据类型 123456789print ('hello world!')c = 'It is a \"dog\"!'print (c)c1= \"It's a dog!\"print (c1)c2 = \"\"\"helloworld!\"\"\"print (c2) 转义字符 123print ('It\\'s a dog!')print (\"hello world!\\nhello Python!\")print ('\\\\\\t\\\\') 123456print (r'\\\\\\t\\\\') #原样输出引号内字符串可以使用在引号前加rs = 'Python'print( 'Py' in s)print( 'py' in s) #切片print (s[2])print (s[1:4]) 字符串连接与格式化输出 123456word1 = '\"hello\"'word2 = '\"world\"'sentence = word1.strip('\"') + ' ' + word2.strip('\"') + '!'print( 'The first word is %s, and the second word is %s' %(word1, word2))print (sentence) 1.2整点与浮点数 Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样 %余数 /取整 浮点数 1230b1111 0xff1.2e-5 运算： 123import mathprint (math.log(math.e)) # 更多运算可查阅文档 布尔值 1.4日期与时间 123456789101112import timenow = time.strptime('2019-08-20', '%Y-%m-%d')print (now)time.strftime('%Y-%m-%d', now) #2019-08-20import datetimesomeDay = datetime.date(1999,2,10)anotherDay = datetime.date(1999,2,15)deltaDay = anotherDay - someDaydeltaDay.days 变量类型12345678910type(None) #NoneTypetype(1.0) #floattype(True) # Trues=\"NoneType\"type(s) #str#类型转化str(10086) #‘10086’float(10086) #10086.0int('10086') #10086complex(10086) #(10086+0j) 数据结构基础列表12345678910111213141516171819202122232425262728mylist= [0, 1, 2, 3, 4, 5]print (mylist)# 索引从0开始，含左不含右print ('[4]=', mylist[4]) #4print ('[-4]=', mylist[-4]) #2print ('[0:4]=', mylist[0:4]) #0,1,2,3print ('[:4]=', mylist[:4])#0,1,2,3print( '[4:]=', mylist[4:])#4,5 ！print ('[0:4:2]=', mylist[0:4:2]) #0,2print ('[-5:-1:]=', mylist[-5:-1:]) #1,2,3,4print ('[-2::-1]=', mylist[-2::-1])#4,3,2,1,0 #goodmylist[3] = \"小月\"print (mylist[3])mylist[5]=\"小楠\"print (mylist[5])mylist[5]=19978print (mylist[5])#插入mylist.append('han') # 添加到尾部mylist.extend(['long', 'wan'])print (mylist)scores = [90, 80, 75, 66]mylist.insert(1, scores) # 添加到指定位置mylist 删除元素 1234567891011print (mylist.pop(1)) # 该函数返回被弹出的元素，不传入参数则删除最后一个元素print (mylist)print( 'wan' in mylist)print ('han' not in mylist) #常见简单判断mylist.count('wan') #计算元素个数mylist.index('wan') #查询位数#列表print (range(10))print (range(-5, 5))print (range(-10, 10, 2))print (range(16, 10, -1)) #【】 元组tuple元组类似列表，元组里面的元素也是进行索引计算。列表里面的元素的值可以修改，而元组里面的元素的值不能修改，只能读取。元组的符号是()。 123456789studentsTuple = (\"ming\", \"jun\", \"qiang\", \"wu\", scores)studentsTupletry: studentsTuple[1] = 'fu'except TypeError: print ('TypeError') #程序常用格式trylen(studentsTuple) #元组不可操作 集合setPython中集合主要有两个功能，一个功能是进行集合操作，另一个功能是消除重复元素。 集合的格式是：set()，其中()内可以是列表、字典或字符串，因为字符串是以列表的形式存储的 123456789101112131415161718192021222324252627studentsSet = set(mylist)print (studentsSet)studentsSet.add('xu')print (studentsSet) #乱序studentsSet.remove('xu')print (studentsSet)a = set(\"abcnmaaaaggsng\")print ('a=', a) #a= {'n', 'g', 'm', 'c', 's', 'b', 'a'}b = set(\"cdfm\")print ('b=', b) #b= {'f', 'm', 'd', 'c'}’‘’集合运算‘’‘#交集x = a &amp; b print( 'x=', x)#并集y = a | bprint ('y=', y)#差集z = a - bprint( 'z=', z)#去除重复元素new = set(a)print( z) 字典dictPython中的字典dict也叫做关联数组，用大括号{}括起来，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，其中key不能重复。 12345678910k = {\"name\":\"weiwei\", \"home\":\"guilin\"}print (k[\"home\"])print( k.keys())print( k.values())k[\"like\"] = \"music\"k['name'] = 'guangzhou'print (k) #添加k.get('edu', -1) # 通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的valuek.pop('like')print (k) #删除元素 数据结构转换（0.0）12345678type(mylist) #listtuple(mylist)list(k) #['name', 'home']zl = zip(('A', 'B', 'C'), [1, 2, 3, 4]) # zip可以将列表、元组、集合、字典‘缝合’起来print (zl)print (dict(zl)) #获得了新知识，猫猫头.jpg#&lt;zip object at 0x00000135BEAF2A88&gt;#{'A': 1, 'B': 2, 'C': 3} python 控制流在Python中通常的情况下程序的执行是从上往下执行的，而某些时候我们为了改变程序的执行顺序，使用控制流语句控制程序执行方式。Python中有三种控制流类型：顺序结构、分支结构、循环结构。 另外，Python可以使用分号”;”分隔语句，但一般是使用换行来分隔；语句块不用大括号”{}”，而使用缩进（可以使用四个空格）来表示 12345678s = '7'num = int(s) # 一般不使用这种分隔方式num -= 1 # num = num - 1 num *= 6 # num = num * 6print (num) #顺序结构'''分支结构if''' 待补充","categories":[{"name":"基础","slug":"基础","permalink":"http://xiaomuhou.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"plan+review","slug":"Fplan/Fplan","date":"2020-07-27T01:34:15.000Z","updated":"2020-07-27T11:03:12.007Z","comments":true,"path":"2020/07/27/Fplan/Fplan/","permalink":"http://xiaomuhou.github.io/2020/07/27/Fplan/Fplan/","excerpt":"2020.7.271.Dynamixel work_bench c++ python 2.python 100 3.movie+6 4.基础 复 习 √ 4.未完待续，下午继续补充……","text":"2020.7.271.Dynamixel work_bench c++ python 2.python 100 3.movie+6 4.基础 复 习 √ 4.未完待续，下午继续补充…… tags 后面也要加空格，浪费了好多时间2333，晚上总结 QAQ复习基础py，资料来源github{https://github.com/fengdu78/Data-Science-Notes/blob/master} 0. 12name = input(\"What is your name?\")print(\"Hello \"+name ) 1. 123456789name=input(\"Name:\")age=input(\"age:\")job=input(\"job:\")info='''---------info of ---------''' + ''' #info of用法Name:'''+name+'''Age:'''+age+'''Job:'''+jobprint(info) 123456789name=input(\"Name:\")age=int(input(\"age:\"))job=input(\"job:\")info='''---------info of ---------Name:%sAge:%dJob:%s'''%(name,age,job)print(info) 123456789name=input(\"Name:\")age=int(input(\"age:\")) job=input(\"job:\")info='''---------info of ---------Name:{_name}Age:{_age}Job:{_job}'''.format(_name=name,_age=age,_job=job) #formatprint(info) 123456789name=input(\"Name:\")age=int(input(\"age:\")) job=input(\"job:\")info='''---------info of ---------Name:{0}Age:{1}Job:{2}'''.format(name,age,job)print(info) 8.隐藏 123import getpasspwd=getpass.getpass(\"请输入密码:\")print(pwd) #知识盲区了2333，可以用来隐藏密码输入... 9. 12345678_username='Alex Li'_password='abc123'username=input(\"username:\")password=input(\"password:\")if _username==username and _password==password: print((\"Welcome user {name} login...\").format(name=username))else: print(\"Invalid username or password!\") 10. 12345678print(\"Hello World\")name = \"Alex Li\"name2=nameprint(name)print(\"My name is\", name,name2) # Alex Li Alex Liname = \"PaoChe Ge\"print(\"My name is\", name,name2) # PaoChe Ge Alex Liprint(\"您好，我来了\") 11.简单，注释而已 ‘’‘ ‘’‘ 12. 123str='''这是第一行内容这是第二行内容'''print(str) #多行 13.简单字符 *mudule*14.模块初始与os 123456import sys# 打印环境变量print(sys.path)print(sys.argv)print(sys.argv[2]) 15. 123456# 进度条import timefor i in range(50): sys.stdout.write('#') sys.stdout.flush() time.sleep(0.5) 16. 12cmd_res = os.system(\"dir\") # os.system()执行后直接输出到终端，然后结束，最后cmd_res保存的是os.system()执行后的状态码print(\"---&gt;\",cmd_res) # ---&gt; 0 17. 12cmd_res1=os.popen(\"dir\")print(\"---&gt;\",cmd_res1) # 得到的是内存对象值 ---&gt; &lt;os._wrap_close object at 0x00000000029187B8&gt; # 有些问题 18. 12cmd_res1=os.popen(\"dir\").read()print(\"---&gt;\",cmd_res1) # 读取数据必须再后面加个read() 19. 12os.mkdir(\"new_dir3\") # 创建一个目录os.removedirs(\"new_dir3\") # 删除一个目录 20.运算问题简单计算 py3和py2 python3中最重要的新特性大概是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示, 二进制数据则由bytes类型表示。Python3不会以任意隐式的方式混用str和bytes，正是这使得两者区分特别清晰。 即：在python2中类型会自动转化，而在python3中则要么报错，要么不转化 str与bytes相互转化 21.bytes与str转化 12345msg=\"我爱北京天安门\"print(msg)print(msg.encode(encoding=\"utf-8\")) # str转bytes,编码print(msg.encode(encoding=\"utf-8\").decode(encoding=\"utf-8\")) # bytes转str,解码 31.python中的循环 1234567891011121314151617181920212223242526272829303132print(\"第一种循环\")count = 0while True: print(\"count:\",count) count+=1 if(count==10): breakprint(\"第二种循环\")count = 0for count in range(0,10,2): print(\"count:\", count)for i in range(0,10): if i&lt;5: print(\"loop \",i) else: continue print(\"hehe....\")my_age=28count = 0while count&lt;3: user_input=int(input(\"input your guess num:\")) if user_input==my_age: print(\"Congratulations,you got it!\") break elif user_input&lt;my_age: print(\"Oops,think bigger!\") else: print(\"think smaller!\") count+=1 print(\"猜这么多次都不对，你个笨蛋.\") 33.三级菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758data={ '北京':{ \"昌平\":{ \"沙河\":[\"oldboys\",'test'], \"天通苑\":[\"链家地产\",\"我爱我家\"] }, \"朝阳\":{ \"望京\":[\"oldboys\",'默陌陌'], \"国贸\":[\"CICC\",\"HP\"], \"东直门\":[\"Advent\",\"飞信\"] }, \"海淀\":{} }, '山东':{ \"德州\":{}, \"青岛\":{}, \"济南\":{} }, '广东':{ \"德州\":{}, \"青岛\":{}, \"济南\":{} },}exit_flag = Falsewhile not exit_flag: for i in data: print(i) choice=input(\"选择进入1&gt;&gt;:\") if choice in data: while not exit_flag: for i2 in data[choice]: print(\"\\t\",i2) choice2=input(\"选择进入2&gt;&gt;:\") if choice2 in data[choice]: while not exit_flag: for i3 in data[choice][choice2]: print(\"\\t\\t\", i3) choice3 = input(\"选择进入3&gt;&gt;:\") if choice3 in data[choice][choice2]: for i4 in data[choice][choice2][choice3]: #RED内层，循环可参考 print(i4) choice4=input(\"最后一层，按b返回&gt;&gt;:\") if choice4=='b': pass # pass可以理解为占位符，表示什么都不做，返回循环起始位置，以后可以在此处添加内容 elif choice4=='q': exit_flag=True if (choice3 == 'b'): break elif choice3 == 'q': exit_flag = True if (choice2 == 'b'): break elif choice2 == 'q': exit_flag = True if (choice == 'b'): break # 32.编码变换 123456789101112# utf-8与gbk互相转化需要通过Unicode作为中介s=\"我爱北京天安门\" # 默认编码为Unicodeprint(s.encode(\"gbk\")) # Unicode可直接转化为gbkprint(s.encode(\"utf-8\")) # Unicode可直接转化为utf-8print(s.encode(\"utf-8\").decode(\"utf-8\").encode(\"gb2312\"))# 此时s.encode(\"utf-8\")即转为utf-8了，然后转为gb2312，则需要先告诉Unicode你原先的编码是什么，即s.encode(\"utf-8\").decode(\"utf-8\"),再对其进行编码为gb2312，即最终为s.encode(\"utf-8\").decode(\"utf-8\").encode(\"gb2312\")打开文件f=open('ly.txt','r',encoding='utf-8') # 文件句柄 'w'为创建文件，之前的数据就没了data=f.read()print(data)f.close()","categories":[],"tags":[{"name":"bor","slug":"bor","permalink":"http://xiaomuhou.github.io/tags/bor/"}]}],"categories":[{"name":"thought2024","slug":"thought2024","permalink":"http://xiaomuhou.github.io/categories/thought2024/"},{"name":"feel","slug":"feel","permalink":"http://xiaomuhou.github.io/categories/feel/"},{"name":"EMO","slug":"EMO","permalink":"http://xiaomuhou.github.io/categories/EMO/"},{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/categories/note/"},{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/categories/emotion/"},{"name":"learning","slug":"learning","permalink":"http://xiaomuhou.github.io/categories/learning/"},{"name":"GPT","slug":"GPT","permalink":"http://xiaomuhou.github.io/categories/GPT/"},{"name":"feeling","slug":"feeling","permalink":"http://xiaomuhou.github.io/categories/feeling/"},{"name":"project","slug":"project","permalink":"http://xiaomuhou.github.io/categories/project/"},{"name":"game","slug":"game","permalink":"http://xiaomuhou.github.io/categories/game/"},{"name":"camera","slug":"camera","permalink":"http://xiaomuhou.github.io/categories/camera/"},{"name":"linux","slug":"linux","permalink":"http://xiaomuhou.github.io/categories/linux/"},{"name":"touch_fish","slug":"touch-fish","permalink":"http://xiaomuhou.github.io/categories/touch-fish/"},{"name":"logic","slug":"logic","permalink":"http://xiaomuhou.github.io/categories/logic/"},{"name":"基础","slug":"基础","permalink":"http://xiaomuhou.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"life","slug":"life","permalink":"http://xiaomuhou.github.io/tags/life/"},{"name":"emo","slug":"emo","permalink":"http://xiaomuhou.github.io/tags/emo/"},{"name":"emotion","slug":"emotion","permalink":"http://xiaomuhou.github.io/tags/emotion/"},{"name":"learning","slug":"learning","permalink":"http://xiaomuhou.github.io/tags/learning/"},{"name":"note","slug":"note","permalink":"http://xiaomuhou.github.io/tags/note/"},{"name":"mathematic","slug":"mathematic","permalink":"http://xiaomuhou.github.io/tags/mathematic/"},{"name":"algebraic","slug":"algebraic","permalink":"http://xiaomuhou.github.io/tags/algebraic/"},{"name":"EMO","slug":"EMO","permalink":"http://xiaomuhou.github.io/tags/EMO/"},{"name":"ACADEMIC","slug":"ACADEMIC","permalink":"http://xiaomuhou.github.io/tags/ACADEMIC/"},{"name":"movie","slug":"movie","permalink":"http://xiaomuhou.github.io/tags/movie/"},{"name":"airfact","slug":"airfact","permalink":"http://xiaomuhou.github.io/tags/airfact/"},{"name":"mathematica","slug":"mathematica","permalink":"http://xiaomuhou.github.io/tags/mathematica/"},{"name":"formula","slug":"formula","permalink":"http://xiaomuhou.github.io/tags/formula/"},{"name":"plan","slug":"plan","permalink":"http://xiaomuhou.github.io/tags/plan/"},{"name":"control","slug":"control","permalink":"http://xiaomuhou.github.io/tags/control/"},{"name":"bor","slug":"bor","permalink":"http://xiaomuhou.github.io/tags/bor/"}]}